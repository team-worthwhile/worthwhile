\section{Beweiserschnittstelle}%

Die Beweiserschnittstelle lässt Worthwhile-""Programmspezifikationen
und -""Annotationen mit Kontext von einem Beweiser überprüfen
und liefert dem Aufrufer dessen Auswertung zurück. Die Auswertung
besteht aus einem Wahrheitswert, einem Modell und einer Liste von
Fehlerausgaben.%

\subsection{Eingabedaten}%

\subsubsection{Programmspezifikation}%

% TODO Datentyp des Abstract-Syntax-Tree

Die Programmspezifikation wird dem Abstract-Syntax-Tree~(AST), welcher
aus einem Worthwhile-Text erstellt wurde, entnommen. Sie setzt sich
zusammen aus dem WHILE-Programmtext und den Annotationen. Annotationen
sind entweder Axiome, Funktionsverträge, Schleifeninvarianten,
Zusicherungen oder Annahmen.%

Siehe \texttt{SpecificationChecker::checkProgram}%

\subsubsection{Annotationen mit Kontext}%

Der Beweiserschnittstelle wird ein AST übergeben, der genau einen
Annotationsausdruck enthält, also insbesondere kein WHILE-Programmtext
oder Annotationstyp. Zusätzlich kann ein Modell als Auswertungskontext
angegeben werden, das im Ausdruck freien Variablen eine Bedeutung
zuweist. Dieses Modell kann zum Beispiel einem Ausführungszustand
entsprechen, sodass Annotationsausdrücke auch für konkrete
Ausführungen (anstatt für alle wie bei
Programmspezifikationsprüfungen) geprüft werden können.%

Siehe \texttt{SpecificationChecker::checkAnnotation}%

\subsection{Formelerstellung im wp-Kalkül für den Beweiser Z3}%

Die Erstellung einer Formel aus einer Programmspezifikation im
wp-Kalkül ist eine Implementierung der Schnittstelle
\texttt{FormulaGenerator} und die Benutzung des Beweisers Z3 für
erstellte Formeln ist eine Implementierung der Schnittstelle
\texttt{ProverCaller}. Beide Implementierungen werden von Worthwhile
mitgeliefert.%

\subsubsection{Axiome}%

Die schließlich an den Beweiser übergebene Formel ist eine
Implikation, auf deren linken Seite die konjunktiv verknüpften Axiome
stehen. Wenn keine Axiome angegeben wurden, steht auf der linke Seite
der Implikation der Wahrheitswert \texttt{true}. Auf der rechten Seite
steht das zu beweisende Theorem, dass das Programm der Spezifikation
entspricht.%

Axiome sind im AST als \texttt{axiom}-Knoten codiert und die Kinder
sind syntaktische Elemente prädikatenlogische Formeln.%

\subsubsection{Funktionsverträge}%

Funktionen werden modular spezifiziert. Ihre Spezifikation besteht aus
den Annahmen, die ihre Parameter für Ergebniskorrektheit erfüllen müssen, und den
Zusicherungen, die sie bei gültigen Parametern für ihr Ergebnis
erfüllen. Annahmen werden Vorbedingungen genannt, Zusicherungen
Nachbedingungen und die Menge aller dieser Bedingungen Funktionsvertrag.%

Für den Funktionsprogrammtext werden die Vorbedingungen wie Axiome behandelt
und Nachbedingungen wie Zusicherungen für den Rückgabewert der
Funktion.%

Vorbedingungen werden im AST als \texttt{requires}-Knoten und
Nachbedingungen als \texttt{ensures}-Knoten codiert. Die Kinder beider
Knotentypen sind syntaktische Elemente prädikatenlogischer Formeln.%

Siehe \texttt{FP020}%

\subsubsection{Schleifeninvarianten}%

Schleifeninvarianten werden in der Formel an den Beweiser so
eingebettet, dass ihre Aussagen vor dem Schleifeneintritt, nach jedem
Durchlauf und nach dem Austritt gelten müssen. Nach jedem Durchlauf
heißt, dass die Erfülltheit der Schleifenbedingung und der Invariante
die Aussage der Invariante impliziert, und nach dem Austritt bedeutet
analog, dass die Erfülltheit der negierten Schleifenbedingung und der
Invariante wiederum die Aussage der Invariante impliziert.%

Schleifeninvarianten werden im AST als \texttt{invariant}-Knoten
codiert, deren Kinder syntaktische Elemente prädikatenlogischer
Formeln sind.%

Siehe \texttt{FP030}%

\subsubsection{Zusicherungen}%

Zusicherungen werden in der Formel an den Beweiser so eingebettet,
dass ihre Aussage bei jeder Programmausführung durch den
vorhergehenden Programmtext erfüllt sein muss.%

Zusicherungen werden im AST als \texttt{assert}-Knoten codiert, deren
Kinder syntaktische Elemente prädikatenlogischer Formeln sind.%

\subsubsection{Annahmen}%

Annahmen werden wie Axiome behandelt, sodass sie insbesondere nicht
wie Zusicherungen erfüllt sein müssen und vom Beweiser auch nicht auf Erfülltheit
geprüft werden.%

Annahmen werden im AST als \texttt{assume}-Knoten codiert,
deren Kinder syntaktische Elemente prädikatenlogischer Formeln sind.%

\subsubsection{Arrayzugriffe}%

Für Arrays werden implizit die drei Axiome (A1), (A2) und (A3)
vorausgesetzt. Außerdem wird jedem Arrayzugriff im Programmtext bei
der Formelerstellung die Zusicherung, dass der angegebene Feldindex
nicht negativ ist und nicht die Deklarationsgröße übersteigt, vorangestellt.%

\begin{description}%
    \item[A1] \begin{math}\forall i \in \mathbb{A}, e \in \mathbb{B} : \{\texttt{true}\} a[i] := e \{a[i] = e\}\end{math}%
    \item[A2] \begin{math}\forall i, j \in \mathbb{A}, e, f \in \mathbb{B} : \{i \neq j \wedge a[i] = e\} a[j] := f \{a[i] = e\}\end{math}%
    \item[A3] \begin{math}\forall a, b \in \mathbb{B}^\mathbb{A} : (\forall i, j \in \mathbb{A} : a[i] = b[j]) \Rightarrow a = b\end{math}%
\end{description}%

\subsubsection{Division}%

Ausdrücken, die eine Division durchführen, wird implizit die Zusicherung
vorangestellt, dass der Dividend ungleich Null ist. Damit wird erreicht, dass
die Möglichkeit eines Programmdurchlaufs, der eine Division durch Null enthält,
auch bei der Prüfung der Spezifikation erkannt und das spezifizierte Programm
nicht als korrekt eingestuft wird, obwohl nicht alle Programmaufrufe mit
definiertem Ergebnis terminieren.%

\subsubsection{Typsystem}%

Die in Worthwhile vorhandenen Datentypen \texttt{Integer} und
\texttt{Boolean} werden beide von dem Beweiser Z3 unterstützt. Die Typen verwendeter Sprachelemente
werden bei Parameterübergabe, Symbolreferenz und Symboldefinition
geprüft. Treten in einem dieser Fälle nicht übereinstimmende Typen auf, liefert Z3 einen
Fehler. Diese Fehler sind in der \texttt{ProverResult}-Rückgabe enthalten.%

\subsection{Kontext für einzelne Annotationen}%

% TODO Datentyp für Programmzustand und ausgewertete Annotationen

Die Bedeutungszuweisung für freie Variablen im Annotationsausdruck werden wie
Axiome behandelt.%

\subsection{Ausgabedaten}%

\subsubsection{Modell}%

\subsubsection{Fehlerausgaben}%

\subsection{Klassenentwurf}%

\begin{itemize}%

    \item Zur Transformation einer Programmspezifikation werden für
    \texttt{WWAST} Besucherklassen für die einzelnen syntaktischen
    Elemente implementiert.%

    \item Die Besucher hängen von Strategieklassen ab, welche die
    Transformationsregeln und die Formelsprache austauschbar machen.%

    Siehe \texttt{Prover::ProgramTransformer::FormulaGenerator}%

    Siehe \texttt{Prover::TheoremProver::FormulaCompiler}%

    % TODO Spezifikation des unterstützten SMT-LIB-Standards

\end{itemize}%

\subsubsection{class Environment}%

Instanzen von \texttt{Environment} fassen einen Programmzustand
zusammen. Dazu gehören sowohl Wertbelegungen für Symbole als auch
erfüllte Annotationen.%

\subsubsection{class WWAST}%

Instanzen von \texttt{WWAST} codieren Programmtexte, welche der Syntax
von Worthwhile entsprechen.%

\subsubsection{class SMTLIBAST}%

Instanzen von \texttt{SMTLIBAST} codieren Programmtexte, welche der
Syntax von SMT-LIB entsprechen.%

\subsubsection{class Prover::Formula}%

Formula beschreibt Instanzen, die prädikatenlogische Formeln als
Syntax~Tree \footnote{Die Syntax prädikatenlogischer Formeln ist
\url{http://formal.iti.kit.edu/teaching/pse/2011/Downloads/intro.pdf}
entnommen} zugänglich machen.%

\subsubsection{class Prover::SpecificationChecker}%

Instanzen von \texttt{SpecificationChecker} übersetzen
\texttt{WWAST}-Instanzen in Instanzen von \texttt{SMTLIBAST}.%

% TODO nicht öffentliche Attribute

\begin{description}%
    \method{private int timeout}%

    Zeit in Sekunden, nach der \texttt{check""Program} und
    \texttt{check""Annotation} zurückkehren müssen.%

    Siehe \texttt{setTimeout}.%

    \method{private SMTLIBAST model}%

\end{description}%

% TODO öffentliche Methoden

\begin{description}%
    \method{public SpecificationChecker(ProverCaller prover, FormulaGenerator generator)}%

    \method{public bool checkProgram(WWAST program)}

    Prüft mit Hilfe eines Beweisers die Korrektheit des annotierten
    Programms \texttt{prg}. Es wird genau dann \texttt{true}
    zurückgeliefert, wenn \texttt{prg} für alle Ausführungen den
    Annotationen entspricht, und \texttt{false} sonst~(z.~B.\, wenn
    \texttt{timeout} überschritten wurde oder die Spezifikation für
    eine Ausführung nicht erfüllt wird).%

    Siehe \texttt{getModel}%

    Siehe \texttt{FP005}%

    \method{public bool checkAnnotation(WWAST annotation, Environment env)}

    Prüft mit Hilfe eines Beweisers die Erfülltheit der Annotation
    \texttt{ann}. Es wird genau dann \texttt{true} zurückgeliefert,
    wenn \texttt{ann} im Kontext \texttt{env} erfüllt ist, und
    \texttt{false} sonst~(z.~B.\, wenn \texttt{timeout} überschritten
    wurde).%

    Siehe \texttt{getModel}%

    Siehe \texttt{FP005}%

    \method{public Environment getModel()}

    Liefert für den vorhergehenden Aufruf von \texttt{check""Program}
    oder \texttt{check""Annotation} die Ausgabe des Beweisers und
    \texttt{null}, wenn zuvor weder ein Programm noch eine Annotation
    überprüft wurde oder keine Ausgabe verfügbar war.%

    \method{public void setTimeout(int seconds)}

    Setzt den Timeout für Aufrufe von \texttt{check""Program} und
    \texttt{check""Annotation} auf den Wert von \texttt{seconds}. Ist
    der angegebene Wert negativ, wird er als Null interpretiert.%

\end{description}%

\subsubsection{interface Prover::ProgramTransformer::FormulaGenerator}%

Implementierungen dieser Schnittstelle erstellen aus einem
Worthwhile-""Programmtext eine prädikatenlogische Formel. Diese Formel
soll nur dann beweisbar sein, wenn das Programm seine Spezifikation
erfüllt. Diese Korrektheit bezieht sich immer auf ein Kalkül, weshalb
Implementierungen dieser Schnittstelle meistens die Produktionsregeln
eines solchen formalen Systems kapseln.%

\begin{description}%
    \method{protected Formula transformProgram(WWAST root)} %

    Liefert die aus \texttt{root} transformierte \texttt{Formula}
    zurück. Die Semantik der Formel ist unbestimmt, falls der
    Programmtext kein semantisch korrektes Programm beschreibt, also
    nicht ausgeführt werden kann. Ansonsten ist die zurückgelieferte
    Formel nur dann beweisbar, wenn im angewendeten Kalkül das
    WHILE-""Programm für alle Ausführungen seinen Annotationen
    entspricht.%

    Parameter \texttt{root}: Wurzelsprachelement des zu
    transformierenden Worthwhile-""Programms, d.~h.\ sowohl der
    WHILE-""Programmtext als auch dessen Annotationen sind im
    Syntaxbaum enthalten.%

\end{description}%

\subsubsection{interface Prover::TheoremProver::ProverCaller}%

Implementierungen dieser Schnittstelle kapseln Aufrufe eines Beweisers
für gegebene prädikatenlogische Formeln. Das Ergebnis eines Aufrufs
besteht aus der Formelerfüllbarkeit, einem Modell zur Verifikation
derselben und einer Liste semantischer Fehler.%

\begin{description}%
    \method{protected ProverResult checkFormula(Formula formula)}%

    Aufruf des unterstützten Beweisers für die Überprüfung der
    prädikatenlogischen Formel \texttt{formula}. Es wird nur dann
    \texttt{true} in \texttt{ProverResult\#satisfiable}
    zurückgeliefert, wenn die Formel erfüllbar ist, und \texttt{false}
    sonst. Ist \texttt{ProverResult\#satisfiable} auf \texttt{true}
    gesetzt, muss \texttt{ProverResult\#model} mit einem
    entsprechenden Modell als Zeuge und \texttt{ProverResult\#errors}
    mit einer leeren Liste initialisiert sein.%

    Parameter \texttt{formula}: Wurzelsprachelement der zu prüfenden
    prädikatenlogischen Formel.%

\end{description}%

\subsubsection{abstract class Prover::TheoremProver::StdProver extends ProverCaller}%

Instanzen von dieser Abstraktion abgeleiteter Klassen rufen Beweiser
auf, denen die zu überprüfende Formel auf der Standardeingabe
übergeben wird. Spezialisierungen dieser Klasse implementieren die
Extrahierung des Beweiserergebnisses aus der Standardausgabe.%

\begin{description}%
    \method{protected StdProver(String path, FormulaCompiler compiler)}%

    Konfiguriert Instanzen so, dass der Beweiser \texttt{path} mit dem
    Formelkompilat von \texttt{compiler} für zu überprüfende
    prädikatenlogische Formeln aufgerufen wird.%

    Parameter \texttt{path}: Systempfad der ausführbaren Datei eines
    Beweisers.%

    Parameter \texttt{compiler}: Wird zur Generierung der
    Beweisereingabe aus einer angegebenen prädikatenlogischen Formel
    aufgerufen.%

    \method{override protected ProverResult checkFormula(Formula formula)}%

    Ruft den bei Objekterstellung angegebenen Beweiserpfad auf und
    füllt die Standardeingabe mit dem vom angegebenen Compiler aus
    \texttt{formula} erstellten Kompilat auf.
    \texttt{ProverResult\#satisfiable} wird auf \texttt{false}
    gesetzt, falls bei der Beweiserausführung ein Systemfehler
    aufgetreten ist, und sonst wird die Rückgabe von
    \texttt{getResult} zurückgeliefert, welche den Inhalt der
    Standardausgabe nach Beweiseraufruf erhalten hat.%

    \method{abstract protected ProverResult getResult(String output)}%

    Extrahiert aus \texttt{output} sowohl Ergebnis als auch Fehler
    eines Beweiseraufrufs und liefert diese Informationen in einer
    Instanz von \texttt{ProverResult} zurück. Kann der Inhalt von
    \texttt{output} nicht interpretiert werden, wird
    \texttt{ProverResult\#satisfiable} auf \texttt{false} gesetzt.%

    Parameter \texttt{output}: Textausgabe nach einem Beweiseraufruf.%

\end{description}%

\subsubsection{interface Prover::TheoremProver::FormulaCompiler}%

Implementierungen dieser Schnittstelle übersetzen eine
\texttt{Formula} in die Eingabesprache eines Beweisers, sodass dieser
mit der zurückgelieferten Zeichenkette die Erfüllbarkeit der
ursprünglichen Formel prüfen und seine Ausgabe in ein verifizierendes
Modell zurückübersetzt werden kann.%

\begin{description}%
    \method{protected String compileFormula(Formula formula)}%

    Liefert eine Übersetzung von \texttt{formula} in eine
    Beweisersprache, sodass das erfüllende Modell eines Beweisers, der
    diese Sprache interpretiert, genau auf ein erfüllendes Modell von
    \texttt{formula} abbilden lässt~(Bedeutungserhalt).%

    %\method{protected Formula uncompileFormula(String formula)}%

\end{description}%

\subsection{Interaktionsentwurf}%
