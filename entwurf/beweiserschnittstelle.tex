\section{Beweiserschnittstelle}%

Die Beweiserschnittstelle lässt Worthwhile-""Programm"-spezifikationen
und prädikatenlogische Formeln mit Kontext von einem Beweiser
überprüfen. Der Formelkontext kann zum Beispiel einem
Ausführungszustand entsprechen, sodass eine Programm"-spezifikation
auch nur für konkrete statt für alle Programmdurchläufe geprüft werden
kann. Das dem Aufrufer zurückgelieferte Überprüfungsergebnis besteht
unter anderem aus der Programm"-spezifikations-"" bzw.\
Formelvalidität.

In den folgenden Abschnitten wird zunächst das Format der Eingaben,
anschließend deren Vorbereitung für einen Beweiseraufruf und zuletzt
die Ergebniserstellung aus der Beweiserausgabe beschrieben.%

\subsection{Eingabedaten}%

\subsubsection{Worthwhile-""Programm"-spezifikation}%

Die Programm"-spezifikation wird dem Abstract-""Syntax-""Tree~(AST)
entnommen, welcher aus einem Worthwhile-""Text erstellt wurde. Sie
setzt sich aus dem WHILE-""Programmtext und den Annotationen
zusammen.%

Siehe \texttt{AST::Program}%

Siehe \texttt{SpecificationChecker::checkProgram}%

\subsubsection{Prädikatenlogische Formel mit Kontext}%

Die Formel wird einem AST entnommen, dessen Wurzelknoten ein
Worthwhile-""Ausdruck ist. Insbesondere ist unbekannt, wo die Formel
in einem Programmtext steht oder wie ihre Validität verwendet wird.
Den Kontext geben eine Abbildung von freien Variablen nach Bedeutungen
und eine Axiomliste an.%

Siehe \texttt{AST::Expression}%

Siehe \texttt{SpecificationChecker::checkAnnotation}%

\subsection{Vorbereitungen für einen Beweiseraufruf}%

In den folgenden Unterabschnitten werden die Vorbereitungen der
Beweiserschnittstelle an den Eingabedaten, bevor diese an den
Beweiser übergeben werden, beschrieben. Die Vorbereitungen
betreffen Worthwhile-spezifische Syntax und Semantik.%

\subsubsection{Axiome}%

Axiome werden als Annahmen behandelt, die für die gesamte
Spezifikation bzw.\ Formel gelten.%

Axiome sind im AST als \texttt{axiom}-Knoten codiert.%

\subsubsection{Funktionsdefinition}%

Funktionen werden modular spezifiziert und überprüft. Ihre
Spezifikation besteht sowohl aus Annahmen über die Aktualparameter
eines Funktionsaufrufs als auch aus Zusicherungen, welche für den
Rückgabewert gelten müssen. Die Annahmen werden Vorbedingungen
genannt und gelten als solche für den gesamten Funktionskörper. Die
Zusicherungen heißen auch Nachbedingungen und bilden zusammen mit den
Vorbedingungen den Funktionsvertrag.%

Im AST werden \texttt{requires}-Knoten als Vorbedingungen und
\texttt{ensures}-Knoten als Nachbedingungen interpretiert.%

Siehe \texttt{FP020}%

\subsubsection{Funktionsaufruf}%

Für jeden Funktionsaufruf in der Spezifikation bzw.\ Formel gilt die
Erfülltheit des jeweiligen Funktionsvertrags als Annahme. Insbesondere
wird der Funktionskörper nicht betrachet.%

\subsubsection{Arrayzugriff}%

Für jeden Arrayzugriff in der Spezifikation bzw.\ Formel gelten die
drei Axiome (A1), (A2) und (A3) als Annahmen \footnote{Die Axiome sind
der Theorie
\url{http://goedel.cs.uiowa.edu/smtlib/theories/ArraysEx.smt2}
entnommen}. Hierbei ist $\mathbb{A}$ eine Indexmenge, $\mathbb{B}$
eine Basismenge sowie $\mathbb{B}^\mathbb{A}$ die Menge aller Arrays
mit der Indexmenge $\mathbb{A}$ und der Basismenge $\mathbb{B}$. %

\begin{description}%
    \item[(A1)] \begin{math}\forall i \in \mathbb{A}, e \in \mathbb{B} : \{\texttt{true}\} a[i] := e \{a[i] = e\}\end{math}%
    \item[(A2)] \begin{math}\forall i, j \in \mathbb{A}, e, f \in \mathbb{B} : \{i \neq j \wedge a[i] = e\} a[j] := f \{a[i] = e\}\end{math}%
    \item[(A3)] \begin{math}\forall a, b \in \mathbb{B}^\mathbb{A} : (\forall i, j \in \mathbb{A} : a[i] = b[j]) \Rightarrow a = b\end{math}%
\end{description}%

Außerdem muss vor jedem Arrayzugriff in der Spezifikation bzw.\ Formel
als Zusicherung gelten, dass der Feldindex des Zugriffs nicht negativ
und echt kleiner als die Deklarationsgröße des Arrays ist. Damit wird
erstens erreicht, dass ein Programmdurchlauf, der einen ungültigen
Arrayzugriff enthält und deswegen entweder gar nicht oder mit
undefiniertem Ergebnis terminiert, für eine valide Spezifikation
ausgeschlossen ist, und zweitens, dass die Validität der Spezifikation
bzw.\ Formel bei ungültigem Feldzugriff unabhängig vom Beweiser
festgelegt ist.%

\subsubsection{Division}%

Vor jeder Division in der Spezifikation bzw.\ Formel muss als
Zusicherung gelten, dass der Dividend ungleich Null ist. Damit wird
erstens erreicht, dass ein Programmdurchlauf, der eine Division durch
Null enthält und deswegen entweder gar nicht oder mit undefiniertem
Ergebnis terminiert, für eine valide Spezifikation ausgeschlossen ist,
und zweitens, dass die Validität der Spezifikation bzw.\ Formel bei
Division durch Null unabhängig vom Beweiser festgelegt ist.%

\subsubsection{Variablendeklarierung}%

Wird eine Variable ohne Initialisierung deklariert, gilt für den
nachfolgenden Spezifikationsteil eine Initialisierung der Variablen
mit dem Standardwert Null für \texttt{Integer}- und \texttt{false} für
\texttt{Boolean}-""Variablen sowie dem jeweiligen Standardwert des
Basistyps für Array-""Variablen als Annahme.%

\subsubsection{Typprüfung}%

Die in Worthwhile vorhandenen Datentypen \texttt{Integer} und
\texttt{Boolean} werden beide vom Beweiser ohne Typkonvertierung
unterstützt. Die Typen von Sprachelementen werden bei Parameterangabe,
Variablenreferenz und Variablendefinition in der Eingabe vom Beweiser
geprüft. Treten in einem dieser Fälle nicht übereinstimmende Typen
auf, liefert der Beweiser einen Typfehler in der Ausgabe und diese ist
im zurückgelieferten Überprüfungsergebnis enthalten.%

\subsubsection{Prädikatenlogische Formel}%

Die prädikatenlogische Formel wird so behandelt, dass sie als
Zusicherung gelten muss.%

\subsubsection{Abbildung von freien Variablen nach Bedeutungen}%

Die Abbildung wird so behandelt, dass in der gesamten Formel die
Annahme gilt, dass die Variablen die angegebenen Bedeutungen haben.%

\subsection{Ausgabedaten}%

\subsubsection{Modell}%

Modelle verifizieren die Erfüllbarkeit von prädikatenlogischen
Formeln, indem sie freie Variablen auf genau ein Element ihrer Domäne
abbilden. Ein Modell, das die Beweiserschnittstelle liefert, besteht
ausschließlich aus Abbildungen, die hinreichend für eine
verifizierende Auswertung der geprüften Formel sind und sich auf im
geprüften Programmteil nicht initialisierte Variablen (z.~B.\
Parameter) beziehen.%

\subsubsection{Fehlerausgaben}%

Fehler, welche von der Beweiserschnittstelle an den Aufrufer
zurückgegeben werden, sind semantische aus der Beweiserausgabe, da der
Syntaxbaum korrekte Syntax erzwingt und die Programmtransformation nur
syntaktische Operationen auf der Programmspezifikation durchführt.
Aufgrund der Behandlung von Laufzeitfehlern wie Nulldivision und
unerlaubtem Arrayfeldzugriff, bleiben als einzige Fehlerausgaben an
den Aufrufer Typfehler und Referenzierung nicht deklarierter Variablen
oder Funktionen.%

\subsection{Klassenentwurf}%

\begin{itemize}%

    \item Zur Transformation einer Programmspezifikation werden für
    \texttt{WWAST} Besucherklassen für die einzelnen syntaktischen
    Elemente implementiert.%

    \item Die Besucher hängen von Strategieklassen ab, welche die
    Transformationsregeln und die Formelsprache austauschbar machen.%

    Siehe \texttt{Prover::ProgramTransformer::FormulaGenerator}%

    Siehe \texttt{Prover::TheoremProver::FormulaCompiler}%

    % TODO Spezifikation des unterstützten SMT-LIB-Standards

\end{itemize}%

\subsubsection{class Environment}%

Instanzen von \texttt{Environment} fassen einen Programmzustand
zusammen. Dazu gehören sowohl Wertbelegungen für Symbole als auch
erfüllte Annotationen.%

\subsubsection{class WWAST}%

Instanzen von \texttt{WWAST} codieren Programmtexte, welche der Syntax
von Worthwhile entsprechen.%

\subsubsection{class Prover::Formula}%

Formula beschreibt Instanzen, die prädikatenlogische Formeln als
Syntaxbaum \footnote{Die Syntax prädikatenlogischer Formeln ist
\url{http://formal.iti.kit.edu/teaching/pse/2011/Downloads/intro.pdf}
entnommen} zugänglich machen.%

\subsubsection{class Prover::SpecificationChecker}%

% TODO Belegung von Funktionsvariablen

Instanzen von \texttt{SpecificationChecker} lassen
\texttt{WWAST}-""Instanzen von einem \texttt{FormulaGenerator} in eine
\texttt{Formula} übersetzen und diese von einem \texttt{ProverCaller}
auf Erfülltheit für alle Belegungen der nicht initialisierten
Programmvariablen überprüfen. Das zurückgelieferte Ergebnis gibt dann
an, ob die Erfülltheit in allen diesen Fällen gegeben ist. Wenn es
Belegungen gibt, für welche die \texttt{Formula} nicht erfüllt ist,
wird eine zur Verifikation des Beweiserergebnisses zurückgegeben.%

% TODO nicht öffentliche Attribute

\begin{description}%
    \method{private int timeout}%

    Zeit in Sekunden, nach der \texttt{check""Program} und
    \texttt{check""Annotation} zurückkehren müssen.%

    Siehe \texttt{setTimeout}.%

    \method{private Map<VariableRef,Literal> model}%

\end{description}%

% TODO öffentliche Methoden

\begin{description}%
    \method{public SpecificationChecker(ProverCaller prover, FormulaGenerator generator)}%

    \method{public bool checkProgram(WWAST program)}

    Prüft mit Hilfe eines Beweisers die Korrektheit des annotierten
    Programms \texttt{prg}. Es wird genau dann \texttt{true}
    zurückgeliefert, wenn \texttt{prg} für alle Ausführungen den
    Annotationen entspricht, und \texttt{false} sonst~(z.~B.\, wenn
    \texttt{timeout} überschritten wurde oder die Spezifikation für
    eine Ausführung nicht erfüllt wird).%

    Siehe \texttt{getModel}%

    Siehe \texttt{FP005}%

    \method{public bool checkAnnotation(WWAST annotation, Environment env)}

    Prüft mit Hilfe eines Beweisers die Erfülltheit der Annotation
    \texttt{ann}. Es wird genau dann \texttt{true} zurückgeliefert,
    wenn \texttt{ann} im Kontext \texttt{env} erfüllt ist, und
    \texttt{false} sonst~(z.~B.\, wenn \texttt{timeout} überschritten
    wurde).%

    Siehe \texttt{getModel}%

    Siehe \texttt{FP005}%

    \method{public Environment getModel()}

    Liefert für den vorhergehenden Aufruf von \texttt{check""Program}
    oder \texttt{check""Annotation} die Ausgabe des Beweisers und
    \texttt{null}, wenn zuvor weder ein Programm noch eine Annotation
    überprüft wurde oder keine Ausgabe verfügbar war.%

    \method{public void setTimeout(int seconds)}

    Setzt den Timeout für Aufrufe von \texttt{check""Program} und
    \texttt{check""Annotation} auf den Wert von \texttt{seconds}. Ist
    der angegebene Wert negativ, wird er als Null interpretiert.%

\end{description}%

\subsubsection{interface Prover::ProgramTransformer::FormulaGenerator}%

Implementierungen dieser Schnittstelle erstellen aus einem
Worthwhile-""Programmtext eine prädikatenlogische Formel. Diese Formel
soll nur dann beweisbar sein, wenn das Programm seine Spezifikation
erfüllt. Diese Korrektheit bezieht sich immer auf ein Kalkül, weshalb
Implementierungen dieser Schnittstelle meistens die Produktionsregeln
eines solchen formalen Systems kapseln.%

\begin{description}%
    \method{protected Formula transformProgram(WWAST root)} %

    Liefert die aus \texttt{root} transformierte \texttt{Formula}
    zurück. Die Semantik der Formel ist unbestimmt, falls der
    Programmtext kein semantisch korrektes Programm beschreibt, also
    nicht ausgeführt werden kann. Ansonsten ist die zurückgelieferte
    Formel nur dann beweisbar, wenn im angewendeten Kalkül das
    WHILE-""Programm für alle Ausführungen seinen Annotationen
    entspricht.%

    Parameter \texttt{root}: Wurzelsprachelement des zu
    transformierenden Worthwhile-""Programms, d.~h.\ sowohl der
    WHILE-""Programmtext als auch dessen Annotationen sind im
    Syntaxbaum enthalten.%

\end{description}%

\subsubsection{interface Prover::TheoremProver::ProverCaller}%

Implementierungen dieser Schnittstelle kapseln Aufrufe eines Beweisers
für gegebene prädikatenlogische Formeln. Das Ergebnis eines Aufrufs
besteht aus der Formelerfüllbarkeit, einem Modell zur Verifikation
derselben und einer Liste semantischer Fehler.%

\begin{description}%
    \method{protected ProverResult checkFormula(Formula formula)}%

    Aufruf des unterstützten Beweisers für die Überprüfung der
    prädikatenlogischen Formel \texttt{formula}. Es wird nur dann
    \texttt{true} in \texttt{ProverResult\#satisfiable}
    zurückgeliefert, wenn die Formel erfüllbar ist, und \texttt{false}
    sonst. Ist \texttt{ProverResult\#satisfiable} auf \texttt{true}
    gesetzt, muss \texttt{ProverResult\#model} mit einem
    entsprechenden Modell als Zeuge und \texttt{ProverResult\#errors}
    mit einer leeren Liste initialisiert sein.%

    Parameter \texttt{formula}: Wurzelsprachelement der zu prüfenden
    prädikatenlogischen Formel.%

\end{description}%

\subsubsection{abstract class Prover::TheoremProver::StdProver extends ProverCaller}%

Instanzen von dieser Abstraktion abgeleiteter Klassen rufen Beweiser
auf, denen die zu überprüfende Formel auf der Standardeingabe
übergeben wird. Spezialisierungen dieser Klasse implementieren die
Extrahierung des Beweiserergebnisses aus der Standardausgabe.%

\begin{description}%
    \method{protected StdProver(String path, FormulaCompiler compiler)}%

    Konfiguriert Instanzen so, dass der Beweiser \texttt{path} mit dem
    Formelkompilat von \texttt{compiler} für zu überprüfende
    prädikatenlogische Formeln aufgerufen wird.%

    Parameter \texttt{path}: Systempfad der ausführbaren Datei eines
    Beweisers.%

    Parameter \texttt{compiler}: Wird zur Generierung der
    Beweisereingabe aus einer angegebenen prädikatenlogischen Formel
    aufgerufen.%

    \method{override protected ProverResult checkFormula(Formula formula)}%

    Ruft den bei Objekterstellung angegebenen Beweiserpfad auf und
    füllt die Standardeingabe mit dem vom angegebenen Compiler aus
    \texttt{formula} erstellten Kompilat auf.
    \texttt{ProverResult\#satisfiable} wird auf \texttt{false}
    gesetzt, falls bei der Beweiserausführung ein Systemfehler
    aufgetreten ist, und sonst wird die Rückgabe von
    \texttt{getResult} zurückgeliefert, welche den Inhalt der
    Standardausgabe nach Beweiseraufruf erhalten hat.%

    \method{abstract protected ProverResult getResult(String output)}%

    Extrahiert aus \texttt{output} sowohl Ergebnis als auch Fehler
    eines Beweiseraufrufs und liefert diese Informationen in einer
    Instanz von \texttt{ProverResult} zurück. Kann der Inhalt von
    \texttt{output} nicht interpretiert werden, wird
    \texttt{ProverResult\#satisfiable} auf \texttt{false} gesetzt.%

    Parameter \texttt{output}: Textausgabe nach einem Beweiseraufruf.%

\end{description}%

\subsubsection{interface Prover::TheoremProver::FormulaCompiler}%

Implementierungen dieser Schnittstelle übersetzen eine
\texttt{Formula} in die Eingabesprache eines Beweisers, sodass dieser
mit der zurückgelieferten Zeichenkette die Erfüllbarkeit der
ursprünglichen Formel prüfen und seine Ausgabe in ein verifizierendes
Modell zurückübersetzt werden kann.%

\begin{description}%
    \method{protected String compileFormula(Formula formula)}%

    Liefert eine Übersetzung von \texttt{formula} in eine
    Beweisersprache, sodass das erfüllende Modell eines Beweisers, der
    diese Sprache interpretiert, genau auf ein erfüllendes Modell von
    \texttt{formula} abbilden lässt~(Bedeutungserhalt).%

    %\method{protected Formula uncompileFormula(String formula)}%

\end{description}%

\subsection{Interaktionsentwurf}%
