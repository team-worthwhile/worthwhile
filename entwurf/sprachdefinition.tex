\section{Sprachdefinition}

\subsection{Trennung von Befehlen}

Die Trennung aufeinanderfolgender Befehle wird dadurch erreicht, dass in jeder Zeile höchstens ein Befehl stehen darf. Dies dient der Übersichtlichkeit, da Befehlstrenner wie das Semikolon unnötig werden.

\subsection{Operatorreihenfolge}

Die folgende Tabelle gibt die Reihenfolge an, in der Operatoren ausgewertet werden. Dabei werden die Operatoren mit höchster Priorität zuerst ausgewertet.

Operatoren mit gleicher Priorität werden von links nach rechts ausgewertet. Durch Klammersetzung kann die Auswertungsreihenfolge beeinflusst werden.

\begin{figure}[H]
\begin{tabular}{|l|l|}
\hline
\textbf{Priorität} & \textbf{Operatoren} \\
\hline
8 & \texttt{{[}\,{]}} \\
\hline
7 & $\neg, -, +$ (unäre Operatoren)\\
\hline
6 & $\cdot, \div, \%$\\
\hline
5 & $+, -$\\
\hline
4 & $<, \leq, \geq, >$\\
\hline
3 & $=$\\
\hline
2 & $\wedge$ \\
\hline
1 & $\vee$ \\
\hline
\end{tabular}
\end{figure}

\subsection{Formale Definition der Grammatik}

Ein Worthwhile-Programm besteht aus genau einem Element des Typs \textit{program}.

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RH

\begin{grammar}

<program> ::= (<funcdecl> | <statement> | <axiom>)* 

<funcdecl> ::= `function' <type> <name> (<parameter>*) \\ (<requires> | <ensures>)* \\ <block>

<statement> ::= <vardecl> | <assign> | <block> | <annotation> | <funccall> | <conditional> | <loop> | <return>

<axiom> ::= `_axiom' (<expr> | <quantifiedexpr>)

<block> ::= `{' <statement>* `}'

<vardecl> ::= <parameter> `:=' <expr>

<assign> ::= <varref> `:=' <expr>

<varref> ::= <name> (`[' <expr> `]' )?

<annotation> ::= (`_assert' | `_assume') (<expr> | <quantifiedexpr>)

<funccall> ::= <name> `(' (<expr> (`,' <expr>)* )? `)'

<conditional> ::= `if' <expr> \\ <block>  \\ (`else' \\ <block>)?

<loop> ::= `while' <expr> \\ <invariant> \\ <block>

<invariant> ::= `_invariant' (<expr> | <quantifiedexpr>)

<return> ::= `return' <expr>

% TODO mark math symbols as tokens
<quantifiedexpr> ::= ($\forall$ | $\exists$ ) <type> <name> (`,' <expr>) (<quantifiedexpr> | `:' <expr>)

<expr> ::= <prefixop> <expr> | <expr> <binop> <expr> | <expr> <postfixop> | `(' <expr> `)' | <literal> | <varref> | <funccall>

<literal> ::= `false' | `true' | <integer>

<type> ::= <primitivetype> | <arraytype>

<primitivetype> ::= `Integer' | `Boolean'

<arraytype> ::= <primitivetype> `[' <expr> `]'

<parameter> ::= <type> <name>

<binop> ::= $\vee$ | $\wedge$ | $\textless$ | $\leq$ | $=$ | $\geq$ | $>$ | $+$ | $-$ | $\cdot$ | $/$

<prefixop> ::= $-$ | $+$ | $\neg$

<postfixop> ::= `[' <expr> `]'

<name> ::=  [`A--Za--z'][`A--Za--z0--9']*

\end{grammar}

\subsection{Alternative Darstellungsweisen für mathematische Symbole}

Einige mathematische Symbole sind auf Tastaturen nicht verfügbar. Daher sind folgende textuelle Alternativen vorgesehen, um die Sprache auch ohne die Hilfe einer IDE editieren zu können:

\begin{figure}[H]
\begin{tabular}{|l|l|}
\hline
\textbf{Symbol} & \textbf{Alternative} \\
\hline
$\forall$ & \texttt{forall} \\
\hline
$\exists$ & \texttt{exists} \\
\hline
$\cdot$ & \texttt{*} \\
\hline
$\neg$ & \texttt{!} \\
\hline
$\vee$ & \texttt{\textbar\textbar} \\
\hline
$\wedge$ & \texttt{\&\&} \\
\hline
$\leq$ & \texttt{<=} \\
\hline
$\geq$ & \texttt{>=} \\
\hline
\end{tabular}
\end{figure}
