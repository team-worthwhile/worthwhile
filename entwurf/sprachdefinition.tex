\section{Sprachdefinition}

\subsection{Operatorreihenfolge}

Die folgende Tabelle gibt die Reihenfolge an, in der Operatoren ausgewertet werden. Dabei werden die Operatoren mit höchster Priorität zuerst ausgewertet.

Operatoren mit gleicher Priorität werden von links nach rechts ausgewertet. Durch Klammersetzung kann die Auswertungsreihenfolge beeinflusst werden.

\begin{figure}[H]
\begin{tabular}{|l|l|}
\hline
\textbf{Priorität} & \textbf{Operatoren} \\
\hline
8 & \texttt{{[}\,{]}} \\
\hline
7 & $\neg, -, +$ (unäre Operatoren)\\
\hline
6 & $\cdot, \div, \%$\\
\hline
5 & $+, -$\\
\hline
4 & $<, \leq, \geq, >$\\
\hline
3 & $=$\\
\hline
2 & $\wedge$ \\
\hline
1 & $\vee$ \\
\hline
\end{tabular}
\end{figure}

\subsection{Formale Definition der Grammatik}

% \setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RH

\begin{grammar}

<program> ::= (<funcdecl> | <statement> | <axiom>)* 

<funcdecl> ::= `function' <type> <name> (<parameter>*) \\ (<requires> | <ensures>)* \\ <block>

<statement> ::= <vardecl> | <assign> | <block> | <annotation> | <funccall> | <conditional> | <loop> | <return>

<axiom> ::= `_axiom' (<expr> | <quantifiedexpr>)

<block> ::= `{' <statement>* `}'

<vardecl> ::= <parameter> `:=' <expr>

<assign> ::= <name> `:=' <expr>

<annotation> ::= (`_assert' | `_assume') (<expr> | <quantifiedexpr>)

<funccall> ::= <name> `(' (<expr> (`,' <expr>)* )? `)'

<conditional> ::= `if' <expr> \\ <block>  \\ (`else' \\ <block>)?

<loop> ::= `while' <expr> \\ <invariant> \\ <block>

<invariant> ::= `_invariant' (<expr> | <quantifiedexpr>)

<return> ::= `return' <expr>

<quantifiedexpr> ::= (`\forall' | `\exists' ) <type> <name> (`,' <expr>) (<quantifiedexpr> | `:' <expr>)

<expr> ::= <prefixop> <expr> | <expr> <binop> <expr> | <expr> <postfixop> | `(' <expr> `)' | <literal> | <variable> | <funccall>

<literal> ::= `false' | `true' | <integer>

<type> ::= <primitivetype> | <arraytype>

<primitivetype> ::= `Integer' | `Boolean'

<arraytype> ::= <primitivetype> `[' <expr> `]'

<parameter> ::= <type> <name>

<binop> ::= $\vee$ | $\wedge$ | $\textless$ | $\leq$ | $=$ | $\geq$ | $>$ | $+$ | $-$ | $\cdot$ | $/$

<prefixop> ::= $-$ | $+$ | $\neg$

<postfixop> ::= `[' <expr> `]'

\end{grammar}

\subsection{Alternative Darstellungsweisen für mathematische Symbole}

Einige mathematische Symbole sind auf Tastaturen nicht verfügbar. Daher sind folgende textuelle Alternativen vorgesehen, um die Sprache auch ohne die Hilfe einer IDE editieren zu können:

\begin{figure}[H]
\begin{tabular}{|l|l|}
\hline
\textbf{Symbol} & \textbf{Alternative} \\
\hline
$\forall$ & \texttt{forall} \\
\hline
$\exists$ & \texttt{exists} \\
\hline
$\cdot$ & \texttt{*} \\
\hline
$\neg$ & \texttt{!} \\
\hline
$\vee$ & \texttt{\textbar\textbar} \\
\hline
$\wedge$ & \texttt{\&\&} \\
\hline
$\leq$ & \texttt{<=} \\
\hline
$\geq$ & \texttt{>=} \\
\hline
\end{tabular}
\end{figure}