\section{Umsetzung von Entwurfsentscheidungen}
% TODO: wichtige entwurfsentscheidungen anhand implementierungsbeispielen
\subsection{Funktionen}
Um rekursive Funktionsaufrufe zu verhindern, wurde das Scoping dergestalt umgesetzt, dass die Referenzierung einer Funktion (insbesondere die Verwendung innerhalb einer anderen Funktion) erst nach ihrer Deklaration möglich ist.

\subsection{Arithmetik}
\subsubsection{Division durch Null \label{umsetzung_division_null}}
Vor jeder Division existiert ein implizierte Zusicherung, dass der Dividend ungleich Null ist. Was bedeutet, dass ein Code ohne diese Zusicherung nicht als Programm gilt. Die Auswirkungen auf die Korrektheit des Programms hängen dementsprechend vom externen Beweiser ab.

\subsubsection{Modulo Null}
Gleiches wie für eine Division durch Null (siehe \ref{umsetzung_division_null}) gilt auch für Modulo Null.

\subsection{Entwurfsmuster}
\subsubsection{Delegation-Pattern}
Das Delegate-Pattern findet hauptsächlich in der GUI Anwendung (bspw. \\ \texttt{WorthwhileLaunchConfigurationDelegate}). Dabei werden Aufgaben an Hilfsklassen weitergegeben.

\subsubsection{Facade-Pattern}
Um den Umgang mit der Beweiserschnittstelle zu erleichtern und ausschließlich ausgewählte Methoden zur Verfügung zu stellen, wurde unter anderem hier das Facade-Pattern angewendet. 

\subsubsection{Observer-Pattern}
Das Oberserver-Pattern wird verwendet, damit der Debugger mit dem Interpreter kommunizieren kann. Dabei informiert der Interpreter den Debugger über bestimmte Ereignisse, wie zum Beispiel, dass ein Statement vollständig abgearbeitet wurde oder das Auftreten eines Fehlers beim Interpretieren. 

\subsubsection{Visitor-Pattern}
Das Visitor-Pattern ist ein zentrales Entwurfsmuster und wird an vielen Stellen im Programm benutzt, da hierdurch beispielsweise die Möglichkeit besteht, die Knoten des ASTs zu traversieren. Zusätzlich zu den allgemein bekannten Funktionen eines Visitors, wie er im Interpreter oder in der Beweiserschnittstelle \\(\texttt{HierarchialASTNodeVisitor}) angewendet wird, haben sich einige Visitor-Implementierungen mit spezieller Funktionalität ergeben, zum Beispiel der \texttt{ASTNodeBottomUpVisitor}, welcher den AST ausgehend von einem Startknoten rückwärts besucht, oder der \\ \texttt{ASTNodeReturnVisitor}, der einen generischen Returnwert besitzt, um beispielsweise Aussagen über das Vorhandensein bestimmter AST-""Knoten geben kann.
