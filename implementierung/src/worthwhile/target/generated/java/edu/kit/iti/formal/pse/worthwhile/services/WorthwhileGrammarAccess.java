/*
* generated by Xtext
*/

package edu.kit.iti.formal.pse.worthwhile.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class WorthwhileGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProgramAction_0 = (Action)cGroup.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Assignment cAxiomsAssignment_2_0_0 = (Assignment)cAlternatives_2_0.eContents().get(0);
		private final RuleCall cAxiomsAxiomParserRuleCall_2_0_0_0 = (RuleCall)cAxiomsAssignment_2_0_0.eContents().get(0);
		private final Assignment cFunctionDeclarationsAssignment_2_0_1 = (Assignment)cAlternatives_2_0.eContents().get(1);
		private final RuleCall cFunctionDeclarationsFunctionDeclarationParserRuleCall_2_0_1_0 = (RuleCall)cFunctionDeclarationsAssignment_2_0_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cMainBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMainBlockBlockParserRuleCall_3_0 = (RuleCall)cMainBlockAssignment_3.eContents().get(0);
		
		//// A program consists of a sequence of statements and/or function declarations.
		//Program:
		//	{Program} NL* // Newline at the beginning of the file is allowed.
		//	((axioms+=Axiom | functionDeclarations+=FunctionDeclaration) NL+)* mainBlock= // FIXME: Newline at end of file?
		//	Block;
		public ParserRule getRule() { return rule; }

		//{Program} NL* // Newline at the beginning of the file is allowed.
		//((axioms+=Axiom | functionDeclarations+=FunctionDeclaration) NL+)* mainBlock= // FIXME: Newline at end of file?
		//Block
		public Group getGroup() { return cGroup; }

		//{Program}
		public Action getProgramAction_0() { return cProgramAction_0; }

		//NL*
		public RuleCall getNLTerminalRuleCall_1() { return cNLTerminalRuleCall_1; }

		//((axioms+=Axiom | functionDeclarations+=FunctionDeclaration) NL+)*
		public Group getGroup_2() { return cGroup_2; }

		//axioms+=Axiom | functionDeclarations+=FunctionDeclaration
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }

		//axioms+=Axiom
		public Assignment getAxiomsAssignment_2_0_0() { return cAxiomsAssignment_2_0_0; }

		//Axiom
		public RuleCall getAxiomsAxiomParserRuleCall_2_0_0_0() { return cAxiomsAxiomParserRuleCall_2_0_0_0; }

		//functionDeclarations+=FunctionDeclaration
		public Assignment getFunctionDeclarationsAssignment_2_0_1() { return cFunctionDeclarationsAssignment_2_0_1; }

		//FunctionDeclaration
		public RuleCall getFunctionDeclarationsFunctionDeclarationParserRuleCall_2_0_1_0() { return cFunctionDeclarationsFunctionDeclarationParserRuleCall_2_0_1_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_2_1() { return cNLTerminalRuleCall_2_1; }

		//mainBlock= // FIXME: Newline at end of file?
		//Block
		public Assignment getMainBlockAssignment_3() { return cMainBlockAssignment_3; }

		//// FIXME: Newline at end of file?
		//Block
		public RuleCall getMainBlockBlockParserRuleCall_3_0() { return cMainBlockBlockParserRuleCall_3_0; }
	}

	public class AxiomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Axiom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword c_axiomKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//// An axiom is declared at the top level in the program and is valid for all annotations.
		//Axiom:
		//	"_axiom" expression=Expression;
		public ParserRule getRule() { return rule; }

		//"_axiom" expression=Expression
		public Group getGroup() { return cGroup; }

		//"_axiom"
		public Keyword get_axiomKeyword_0() { return c_axiomKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_1_0_0 = (RuleCall)cStatementsAssignment_1_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//// A block consists of one or multiple statements.
		//Block:
		//	{Block} (statements+=Statement NL+)*;
		public ParserRule getRule() { return rule; }

		//{Block} (statements+=Statement NL+)*
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//(statements+=Statement NL+)*
		public Group getGroup_1() { return cGroup_1; }

		//statements+=Statement
		public Assignment getStatementsAssignment_1_0() { return cStatementsAssignment_1_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_0_0() { return cStatementsStatementParserRuleCall_1_0_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_1_1() { return cNLTerminalRuleCall_1_1; }
	}

	public class BracedBlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BracedBlock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cStatementsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_3_0_0 = (RuleCall)cStatementsAssignment_3_0.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// This is a block enclosed in curly braces
		//BracedBlock returns Block:
		//	{Block} "{" NL* (statements+=Statement NL+)* "}";
		public ParserRule getRule() { return rule; }

		//{Block} "{" NL* (statements+=Statement NL+)* "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//NL*
		public RuleCall getNLTerminalRuleCall_2() { return cNLTerminalRuleCall_2; }

		//(statements+=Statement NL+)*
		public Group getGroup_3() { return cGroup_3; }

		//statements+=Statement
		public Assignment getStatementsAssignment_3_0() { return cStatementsAssignment_3_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_0_0() { return cStatementsStatementParserRuleCall_3_0_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_3_1() { return cNLTerminalRuleCall_3_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBracedBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIfStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWhileStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cReturnStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//// A statement is everything that can be executed in the program.
		//Statement:
		//	VariableDeclaration | Assignment | BracedBlock | Annotation | IfStatement | WhileStatement | ReturnStatement;
		public ParserRule getRule() { return rule; }

		//VariableDeclaration | Assignment | BracedBlock | Annotation | IfStatement | WhileStatement | ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//BracedBlock
		public RuleCall getBracedBlockParserRuleCall_2() { return cBracedBlockParserRuleCall_2; }

		//Annotation
		public RuleCall getAnnotationParserRuleCall_3() { return cAnnotationParserRuleCall_3; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_4() { return cIfStatementParserRuleCall_4; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_5() { return cWhileStatementParserRuleCall_5; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_6() { return cReturnStatementParserRuleCall_6; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnValueExpressionParserRuleCall_1_0 = (RuleCall)cReturnValueAssignment_1.eContents().get(0);
		
		//// A return statement returns a value from a function.
		//ReturnStatement:
		//	"return" returnValue=Expression;
		public ParserRule getRule() { return rule; }

		//"return" returnValue=Expression
		public Group getGroup() { return cGroup; }

		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }

		//returnValue=Expression
		public Assignment getReturnValueAssignment_1() { return cReturnValueAssignment_1; }

		//Expression
		public RuleCall getReturnValueExpressionParserRuleCall_1_0() { return cReturnValueExpressionParserRuleCall_1_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cInvariantsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInvariantsInvariantParserRuleCall_2_0 = (RuleCall)cInvariantsAssignment_2.eContents().get(0);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyBracedBlockParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//// A while statement specifies a while loop.
		//WhileStatement returns Loop:
		//	"while" condition=Expression invariants+=Invariant* body=BracedBlock;
		public ParserRule getRule() { return rule; }

		//"while" condition=Expression invariants+=Invariant* body=BracedBlock
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }

		//invariants+=Invariant*
		public Assignment getInvariantsAssignment_2() { return cInvariantsAssignment_2; }

		//Invariant
		public RuleCall getInvariantsInvariantParserRuleCall_2_0() { return cInvariantsInvariantParserRuleCall_2_0; }

		//body=BracedBlock
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }

		//BracedBlock
		public RuleCall getBodyBracedBlockParserRuleCall_3_0() { return cBodyBracedBlockParserRuleCall_3_0; }
	}

	public class InvariantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Invariant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword c_invariantKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// An invariant can be used to specify the invariants of a WHILE loop.
		//Invariant:
		//	"_invariant" expression=Expression NL+;
		public ParserRule getRule() { return rule; }

		//"_invariant" expression=Expression NL+
		public Group getGroup() { return cGroup; }

		//"_invariant"
		public Keyword get_invariantKeyword_0() { return c_invariantKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_2() { return cNLTerminalRuleCall_2; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cTrueBlockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTrueBlockBracedBlockParserRuleCall_2_0 = (RuleCall)cTrueBlockAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cElseKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFalseBlockAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFalseBlockBracedBlockParserRuleCall_3_1_0 = (RuleCall)cFalseBlockAssignment_3_1.eContents().get(0);
		
		//// An if statement specifies a conditional Expression.
		//IfStatement returns Conditional:
		//	"if" condition=Expression trueBlock=BracedBlock ("else" falseBlock=BracedBlock)?;
		public ParserRule getRule() { return rule; }

		//"if" condition=Expression trueBlock=BracedBlock ("else" falseBlock=BracedBlock)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }

		//trueBlock=BracedBlock
		public Assignment getTrueBlockAssignment_2() { return cTrueBlockAssignment_2; }

		//BracedBlock
		public RuleCall getTrueBlockBracedBlockParserRuleCall_2_0() { return cTrueBlockBracedBlockParserRuleCall_2_0; }

		//("else" falseBlock=BracedBlock)?
		public Group getGroup_3() { return cGroup_3; }

		//"else"
		public Keyword getElseKeyword_3_0() { return cElseKeyword_3_0; }

		//falseBlock=BracedBlock
		public Assignment getFalseBlockAssignment_3_1() { return cFalseBlockAssignment_3_1; }

		//BracedBlock
		public RuleCall getFalseBlockBracedBlockParserRuleCall_3_1_0() { return cFalseBlockBracedBlockParserRuleCall_3_1_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnTypeTypeParserRuleCall_1_0 = (RuleCall)cReturnTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cParametersAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_4_0_0 = (RuleCall)cParametersAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cParametersAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_4_1_1_0 = (RuleCall)cParametersAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final RuleCall cNLTerminalRuleCall_6 = (RuleCall)cGroup.eContents().get(6);
		private final Alternatives cAlternatives_7 = (Alternatives)cGroup.eContents().get(7);
		private final Assignment cPreconditionsAssignment_7_0 = (Assignment)cAlternatives_7.eContents().get(0);
		private final RuleCall cPreconditionsRequireParserRuleCall_7_0_0 = (RuleCall)cPreconditionsAssignment_7_0.eContents().get(0);
		private final Assignment cPostconditionsAssignment_7_1 = (Assignment)cAlternatives_7.eContents().get(1);
		private final RuleCall cPostconditionsEnsureParserRuleCall_7_1_0 = (RuleCall)cPostconditionsAssignment_7_1.eContents().get(0);
		private final Assignment cBodyAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBodyBracedBlockParserRuleCall_8_0 = (RuleCall)cBodyAssignment_8.eContents().get(0);
		
		//// A function declaration declares a function name, parameters, return type, and function body.
		//FunctionDeclaration:
		//	"function" returnType=Type name=ID "(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")" NL*
		//	(preconditions+=Require | postconditions+=Ensure)* body=BracedBlock;
		public ParserRule getRule() { return rule; }

		//"function" returnType=Type name=ID "(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")" NL*
		//(preconditions+=Require | postconditions+=Ensure)* body=BracedBlock
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_1() { return cReturnTypeAssignment_1; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_1_0() { return cReturnTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(parameters+=Parameter ("," parameters+=Parameter)*)?
		public Group getGroup_4() { return cGroup_4; }

		//parameters+=Parameter
		public Assignment getParametersAssignment_4_0() { return cParametersAssignment_4_0; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_4_0_0() { return cParametersParameterParserRuleCall_4_0_0; }

		//("," parameters+=Parameter)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//parameters+=Parameter
		public Assignment getParametersAssignment_4_1_1() { return cParametersAssignment_4_1_1; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_4_1_1_0() { return cParametersParameterParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//NL*
		public RuleCall getNLTerminalRuleCall_6() { return cNLTerminalRuleCall_6; }

		//(preconditions+=Require | postconditions+=Ensure)*
		public Alternatives getAlternatives_7() { return cAlternatives_7; }

		//preconditions+=Require
		public Assignment getPreconditionsAssignment_7_0() { return cPreconditionsAssignment_7_0; }

		//Require
		public RuleCall getPreconditionsRequireParserRuleCall_7_0_0() { return cPreconditionsRequireParserRuleCall_7_0_0; }

		//postconditions+=Ensure
		public Assignment getPostconditionsAssignment_7_1() { return cPostconditionsAssignment_7_1; }

		//Ensure
		public RuleCall getPostconditionsEnsureParserRuleCall_7_1_0() { return cPostconditionsEnsureParserRuleCall_7_1_0; }

		//body=BracedBlock
		public Assignment getBodyAssignment_8() { return cBodyAssignment_8; }

		//BracedBlock
		public RuleCall getBodyBracedBlockParserRuleCall_8_0() { return cBodyBracedBlockParserRuleCall_8_0; }
	}

	public class RequireElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Require");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword c_requiresKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// Preconditions are specified using the _requires keyword.
		//Require returns Precondition:
		//	"_requires" expression=Expression NL+;
		public ParserRule getRule() { return rule; }

		//"_requires" expression=Expression NL+
		public Group getGroup() { return cGroup; }

		//"_requires"
		public Keyword get_requiresKeyword_0() { return c_requiresKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_2() { return cNLTerminalRuleCall_2; }
	}

	public class EnsureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Ensure");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword c_ensuresKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// Preconditions are specified using the _ensures keyword.
		//Ensure returns Postcondition:
		//	"_ensures" expression=Expression NL+;
		public ParserRule getRule() { return rule; }

		//"_ensures" expression=Expression NL+
		public Group getGroup() { return cGroup; }

		//"_ensures"
		public Keyword get_ensuresKeyword_0() { return c_ensuresKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }

		//NL+
		public RuleCall getNLTerminalRuleCall_2() { return cNLTerminalRuleCall_2; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// A function parameter definition describes a single parameter (type and name) accepted by a function or introduced by a quantifier
		//Parameter returns VariableDeclaration:
		//	{VariableDeclaration} type=Type name=ID;
		public ParserRule getRule() { return rule; }

		//{VariableDeclaration} type=Type name=ID
		public Group getGroup() { return cGroup; }

		//{VariableDeclaration}
		public Action getVariableDeclarationAction_0() { return cVariableDeclarationAction_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A type can either be a primitive type or an array of a primitive type
		//Type:
		//	PrimitiveType | ArrayType;
		public ParserRule getRule() { return rule; }

		//PrimitiveType | ArrayType
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0() { return cPrimitiveTypeParserRuleCall_0; }

		//ArrayType
		public RuleCall getArrayTypeParserRuleCall_1() { return cArrayTypeParserRuleCall_1; }
	}

	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cIntegerTypeAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cIntegerKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBooleanTypeAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cBooleanKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//// A primitive type represents a variable type that can hold one value.
		//PrimitiveType:
		//	{IntegerType} "Integer" | {BooleanType} "Boolean";
		public ParserRule getRule() { return rule; }

		//{IntegerType} "Integer" | {BooleanType} "Boolean"
		public Alternatives getAlternatives() { return cAlternatives; }

		//{IntegerType} "Integer"
		public Group getGroup_0() { return cGroup_0; }

		//{IntegerType}
		public Action getIntegerTypeAction_0_0() { return cIntegerTypeAction_0_0; }

		//"Integer"
		public Keyword getIntegerKeyword_0_1() { return cIntegerKeyword_0_1; }

		//{BooleanType} "Boolean"
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanType}
		public Action getBooleanTypeAction_1_0() { return cBooleanTypeAction_1_0; }

		//"Boolean"
		public Keyword getBooleanKeyword_1_1() { return cBooleanKeyword_1_1; }
	}

	public class ArrayTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArrayTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBaseTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBaseTypePrimitiveTypeParserRuleCall_1_0 = (RuleCall)cBaseTypeAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cSizeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSizeExpressionParserRuleCall_3_0 = (RuleCall)cSizeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// An array type represents an array of a primitive type.
		//ArrayType:
		//	{ArrayType} baseType=PrimitiveType "[" size=Expression "]";
		public ParserRule getRule() { return rule; }

		//{ArrayType} baseType=PrimitiveType "[" size=Expression "]"
		public Group getGroup() { return cGroup; }

		//{ArrayType}
		public Action getArrayTypeAction_0() { return cArrayTypeAction_0; }

		//baseType=PrimitiveType
		public Assignment getBaseTypeAssignment_1() { return cBaseTypeAssignment_1; }

		//PrimitiveType
		public RuleCall getBaseTypePrimitiveTypeParserRuleCall_1_0() { return cBaseTypePrimitiveTypeParserRuleCall_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//size=Expression
		public Assignment getSizeAssignment_3() { return cSizeAssignment_3; }

		//Expression
		public RuleCall getSizeExpressionParserRuleCall_3_0() { return cSizeExpressionParserRuleCall_3_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFunctionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cFunctionFunctionDeclarationCrossReference_0_0 = (CrossReference)cFunctionAssignment_0.eContents().get(0);
		private final RuleCall cFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1 = (RuleCall)cFunctionFunctionDeclarationCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActualsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActualsExpressionParserRuleCall_2_0 = (RuleCall)cActualsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cActualsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cActualsExpressionParserRuleCall_3_1_0 = (RuleCall)cActualsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// A function call simply calls a function without returning a value.
		//FunctionCall:
		//	function=[FunctionDeclaration] "(" actuals+=Expression? ("," actuals+=Expression)* ")";
		public ParserRule getRule() { return rule; }

		//function=[FunctionDeclaration] "(" actuals+=Expression? ("," actuals+=Expression)* ")"
		public Group getGroup() { return cGroup; }

		//function=[FunctionDeclaration]
		public Assignment getFunctionAssignment_0() { return cFunctionAssignment_0; }

		//[FunctionDeclaration]
		public CrossReference getFunctionFunctionDeclarationCrossReference_0_0() { return cFunctionFunctionDeclarationCrossReference_0_0; }

		//ID
		public RuleCall getFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1() { return cFunctionFunctionDeclarationIDTerminalRuleCall_0_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//actuals+=Expression?
		public Assignment getActualsAssignment_2() { return cActualsAssignment_2; }

		//Expression
		public RuleCall getActualsExpressionParserRuleCall_2_0() { return cActualsExpressionParserRuleCall_2_0; }

		//("," actuals+=Expression)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//actuals+=Expression
		public Assignment getActualsAssignment_3_1() { return cActualsAssignment_3_1; }

		//Expression
		public RuleCall getActualsExpressionParserRuleCall_3_1_0() { return cActualsExpressionParserRuleCall_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Annotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final Action cAssertionAction_0_0_0 = (Action)cGroup_0_0.eContents().get(0);
		private final Keyword c_assertKeyword_0_0_1 = (Keyword)cGroup_0_0.eContents().get(1);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Action cAssumptionAction_0_1_0 = (Action)cGroup_0_1.eContents().get(0);
		private final Keyword c_assumeKeyword_0_1_1 = (Keyword)cGroup_0_1.eContents().get(1);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		
		//// An annotation is used to specify assertions and assumptions.
		//Annotation:
		//	({Assertion} "_assert" | {Assumption} "_assume") expression=Expression;
		public ParserRule getRule() { return rule; }

		//({Assertion} "_assert" | {Assumption} "_assume") expression=Expression
		public Group getGroup() { return cGroup; }

		//{Assertion} "_assert" | {Assumption} "_assume"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//{Assertion} "_assert"
		public Group getGroup_0_0() { return cGroup_0_0; }

		//{Assertion}
		public Action getAssertionAction_0_0_0() { return cAssertionAction_0_0_0; }

		//"_assert"
		public Keyword get_assertKeyword_0_0_1() { return c_assertKeyword_0_0_1; }

		//{Assumption} "_assume"
		public Group getGroup_0_1() { return cGroup_0_1; }

		//{Assumption}
		public Action getAssumptionAction_0_1_0() { return cAssumptionAction_0_1_0; }

		//"_assume"
		public Keyword get_assumeKeyword_0_1_1() { return c_assumeKeyword_0_1_1; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }
	}

	public class QuantifiedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifiedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Group cGroup_0_0_0 = (Group)cAlternatives_0_0.eContents().get(0);
		private final Action cForAllQuantifierAction_0_0_0_0 = (Action)cGroup_0_0_0.eContents().get(0);
		private final Alternatives cAlternatives_0_0_0_1 = (Alternatives)cGroup_0_0_0.eContents().get(1);
		private final Keyword cForallKeyword_0_0_0_1_0 = (Keyword)cAlternatives_0_0_0_1.eContents().get(0);
		private final Keyword cForAllKeyword_0_0_0_1_1 = (Keyword)cAlternatives_0_0_0_1.eContents().get(1);
		private final Group cGroup_0_0_1 = (Group)cAlternatives_0_0.eContents().get(1);
		private final Action cExistsQuantifierAction_0_0_1_0 = (Action)cGroup_0_0_1.eContents().get(0);
		private final Alternatives cAlternatives_0_0_1_1 = (Alternatives)cGroup_0_0_1.eContents().get(1);
		private final Keyword cExistsKeyword_0_0_1_1_0 = (Keyword)cAlternatives_0_0_1_1.eContents().get(0);
		private final Keyword cThereExistsKeyword_0_0_1_1_1 = (Keyword)cAlternatives_0_0_1_1.eContents().get(1);
		private final Assignment cParameterAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cParameterParameterParserRuleCall_0_1_0 = (RuleCall)cParameterAssignment_0_1.eContents().get(0);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cConditionAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_0_2_1_0 = (RuleCall)cConditionAssignment_0_2_1.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cExpressionQuantifiedExpressionParserRuleCall_1_0_0 = (RuleCall)cExpressionAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cColonKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cExpressionAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_1_1_0 = (RuleCall)cExpressionAssignment_1_1_1.eContents().get(0);
		
		//// A quantified Expression is an Expression optionally preceded by some quantifier definitions.
		//QuantifiedExpression:
		//	(({ForAllQuantifier} ("forall" | "∀") | {ExistsQuantifier} ("exists" | "∃")) parameter=Parameter (","
		//	condition=Expression)?) (expression=QuantifiedExpression | ":" expression=Expression);
		public ParserRule getRule() { return rule; }

		//(({ForAllQuantifier} ("forall" | "∀") | {ExistsQuantifier} ("exists" | "∃")) parameter=Parameter (","
		//condition=Expression)?) (expression=QuantifiedExpression | ":" expression=Expression)
		public Group getGroup() { return cGroup; }

		//({ForAllQuantifier} ("forall" | "∀") | {ExistsQuantifier} ("exists" | "∃")) parameter=Parameter (","
		//condition=Expression)?
		public Group getGroup_0() { return cGroup_0; }

		//{ForAllQuantifier} ("forall" | "∀") | {ExistsQuantifier} ("exists" | "∃")
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//{ForAllQuantifier} ("forall" | "∀")
		public Group getGroup_0_0_0() { return cGroup_0_0_0; }

		//{ForAllQuantifier}
		public Action getForAllQuantifierAction_0_0_0_0() { return cForAllQuantifierAction_0_0_0_0; }

		//"forall" | "∀"
		public Alternatives getAlternatives_0_0_0_1() { return cAlternatives_0_0_0_1; }

		//"forall"
		public Keyword getForallKeyword_0_0_0_1_0() { return cForallKeyword_0_0_0_1_0; }

		//"∀"
		public Keyword getForAllKeyword_0_0_0_1_1() { return cForAllKeyword_0_0_0_1_1; }

		//{ExistsQuantifier} ("exists" | "∃")
		public Group getGroup_0_0_1() { return cGroup_0_0_1; }

		//{ExistsQuantifier}
		public Action getExistsQuantifierAction_0_0_1_0() { return cExistsQuantifierAction_0_0_1_0; }

		//"exists" | "∃"
		public Alternatives getAlternatives_0_0_1_1() { return cAlternatives_0_0_1_1; }

		//"exists"
		public Keyword getExistsKeyword_0_0_1_1_0() { return cExistsKeyword_0_0_1_1_0; }

		//"∃"
		public Keyword getThereExistsKeyword_0_0_1_1_1() { return cThereExistsKeyword_0_0_1_1_1; }

		//parameter=Parameter
		public Assignment getParameterAssignment_0_1() { return cParameterAssignment_0_1; }

		//Parameter
		public RuleCall getParameterParameterParserRuleCall_0_1_0() { return cParameterParameterParserRuleCall_0_1_0; }

		//("," condition=Expression)?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//","
		public Keyword getCommaKeyword_0_2_0() { return cCommaKeyword_0_2_0; }

		//condition=Expression
		public Assignment getConditionAssignment_0_2_1() { return cConditionAssignment_0_2_1; }

		//Expression
		public RuleCall getConditionExpressionParserRuleCall_0_2_1_0() { return cConditionExpressionParserRuleCall_0_2_1_0; }

		//expression=QuantifiedExpression | ":" expression=Expression
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//expression=QuantifiedExpression
		public Assignment getExpressionAssignment_1_0() { return cExpressionAssignment_1_0; }

		//QuantifiedExpression
		public RuleCall getExpressionQuantifiedExpressionParserRuleCall_1_0_0() { return cExpressionQuantifiedExpressionParserRuleCall_1_0_0; }

		//":" expression=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }

		//":"
		public Keyword getColonKeyword_1_1_0() { return cColonKeyword_1_1_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1_1_1() { return cExpressionAssignment_1_1_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_1_1_0() { return cExpressionExpressionParserRuleCall_1_1_1_0; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cInitialValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cInitialValueExpressionParserRuleCall_4_0 = (RuleCall)cInitialValueAssignment_4.eContents().get(0);
		
		//// A variable declaration declares a new variable and assigns it a value.
		//VariableDeclaration:
		//	{VariableDeclaration} type=Type name=ID ":=" initialValue=Expression;
		public ParserRule getRule() { return rule; }

		//{VariableDeclaration} type=Type name=ID ":=" initialValue=Expression
		public Group getGroup() { return cGroup; }

		//{VariableDeclaration}
		public Action getVariableDeclarationAction_0() { return cVariableDeclarationAction_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_3() { return cColonEqualsSignKeyword_3; }

		//initialValue=Expression
		public Assignment getInitialValueAssignment_4() { return cInitialValueAssignment_4; }

		//Expression
		public RuleCall getInitialValueExpressionParserRuleCall_4_0() { return cInitialValueExpressionParserRuleCall_4_0; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableVariableReferenceParserRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// An assignment assigns a value to a variable.
		//Assignment:
		//	variable=VariableReference ":=" value=Expression;
		public ParserRule getRule() { return rule; }

		//variable=VariableReference ":=" value=Expression
		public Group getGroup() { return cGroup; }

		//variable=VariableReference
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//VariableReference
		public RuleCall getVariableVariableReferenceParserRuleCall_0_0() { return cVariableVariableReferenceParserRuleCall_0_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cQuantifiedExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanOrParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// An Expression is based on operator precedence. Each "level" of Expressions means one level of operator precedence,
		//// where the last operation specified has the highest priority. In the same level, operators are evaluated from left to right.
		//Expression:
		//	QuantifiedExpression | BooleanOr;
		public ParserRule getRule() { return rule; }

		//QuantifiedExpression | BooleanOr
		public Alternatives getAlternatives() { return cAlternatives; }

		//QuantifiedExpression
		public RuleCall getQuantifiedExpressionParserRuleCall_0() { return cQuantifiedExpressionParserRuleCall_0; }

		//BooleanOr
		public RuleCall getBooleanOrParserRuleCall_1() { return cBooleanOrParserRuleCall_1; }
	}

	public class BooleanOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBooleanAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDisjunctionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cLogicalOrKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBooleanAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// The boolean or has the lowest priority.
		//BooleanOr returns Expression:
		//	BooleanAnd ({Disjunction.left=current} ("∨" | "||") right=BooleanAnd)?;
		public ParserRule getRule() { return rule; }

		//BooleanAnd ({Disjunction.left=current} ("∨" | "||") right=BooleanAnd)?
		public Group getGroup() { return cGroup; }

		//BooleanAnd
		public RuleCall getBooleanAndParserRuleCall_0() { return cBooleanAndParserRuleCall_0; }

		//({Disjunction.left=current} ("∨" | "||") right=BooleanAnd)?
		public Group getGroup_1() { return cGroup_1; }

		//{Disjunction.left=current}
		public Action getDisjunctionLeftAction_1_0() { return cDisjunctionLeftAction_1_0; }

		//"∨" | "||"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"∨"
		public Keyword getLogicalOrKeyword_1_1_0() { return cLogicalOrKeyword_1_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_1_1() { return cVerticalLineVerticalLineKeyword_1_1_1; }

		//right=BooleanAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BooleanAnd
		public RuleCall getRightBooleanAndParserRuleCall_1_2_0() { return cRightBooleanAndParserRuleCall_1_2_0; }
	}

	public class BooleanAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualsComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cConjunctionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cLogicalAndKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualsComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// The boolean and has second lowest priority.
		//BooleanAnd returns Expression:
		//	EqualsComparison ({Conjunction.left=current} ("∧" | "&&") right=EqualsComparison)?;
		public ParserRule getRule() { return rule; }

		//EqualsComparison ({Conjunction.left=current} ("∧" | "&&") right=EqualsComparison)?
		public Group getGroup() { return cGroup; }

		//EqualsComparison
		public RuleCall getEqualsComparisonParserRuleCall_0() { return cEqualsComparisonParserRuleCall_0; }

		//({Conjunction.left=current} ("∧" | "&&") right=EqualsComparison)?
		public Group getGroup_1() { return cGroup_1; }

		//{Conjunction.left=current}
		public Action getConjunctionLeftAction_1_0() { return cConjunctionLeftAction_1_0; }

		//"∧" | "&&"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"∧"
		public Keyword getLogicalAndKeyword_1_1_0() { return cLogicalAndKeyword_1_1_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_1_1() { return cAmpersandAmpersandKeyword_1_1_1; }

		//right=EqualsComparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//EqualsComparison
		public RuleCall getRightEqualsComparisonParserRuleCall_1_2_0() { return cRightEqualsComparisonParserRuleCall_1_2_0; }
	}

	public class EqualsComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualsComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cEqualLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cUnequalLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1_1 = (Alternatives)cGroup_1_0_1.eContents().get(1);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_1_1_0 = (Keyword)cAlternatives_1_0_1_1.eContents().get(0);
		private final Keyword cNotEqualToKeyword_1_0_1_1_1 = (Keyword)cAlternatives_1_0_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// The equal and unequal comparisons are next in priority.
		//EqualsComparison returns Expression:
		//	Comparison (({Equal.left=current} "=" | {Unequal.left=current} ("!=" | "≠")) right=Comparison)?;
		public ParserRule getRule() { return rule; }

		//Comparison (({Equal.left=current} "=" | {Unequal.left=current} ("!=" | "≠")) right=Comparison)?
		public Group getGroup() { return cGroup; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }

		//(({Equal.left=current} "=" | {Unequal.left=current} ("!=" | "≠")) right=Comparison)?
		public Group getGroup_1() { return cGroup_1; }

		//{Equal.left=current} "=" | {Unequal.left=current} ("!=" | "≠")
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Equal.left=current} "="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_0_0() { return cEqualLeftAction_1_0_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_0_1() { return cEqualsSignKeyword_1_0_0_1; }

		//{Unequal.left=current} ("!=" | "≠")
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Unequal.left=current}
		public Action getUnequalLeftAction_1_0_1_0() { return cUnequalLeftAction_1_0_1_0; }

		//"!=" | "≠"
		public Alternatives getAlternatives_1_0_1_1() { return cAlternatives_1_0_1_1; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_1_1_0() { return cExclamationMarkEqualsSignKeyword_1_0_1_1_0; }

		//"≠"
		public Keyword getNotEqualToKeyword_1_0_1_1_1() { return cNotEqualToKeyword_1_0_1_1_1; }

		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cLessLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cLessOrEqualLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1_1 = (Alternatives)cGroup_1_0_1.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1_1_0 = (Keyword)cAlternatives_1_0_1_1.eContents().get(0);
		private final Keyword cLessThanOrEqualToKeyword_1_0_1_1_1 = (Keyword)cAlternatives_1_0_1_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cGreaterOrEqualLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Alternatives cAlternatives_1_0_2_1 = (Alternatives)cGroup_1_0_2.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_2_1_0 = (Keyword)cAlternatives_1_0_2_1.eContents().get(0);
		private final Keyword cGreaterThanOrEqualToKeyword_1_0_2_1_1 = (Keyword)cAlternatives_1_0_2_1.eContents().get(1);
		private final Group cGroup_1_0_3 = (Group)cAlternatives_1_0.eContents().get(3);
		private final Action cGreaterLeftAction_1_0_3_0 = (Action)cGroup_1_0_3.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_3_1 = (Keyword)cGroup_1_0_3.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAdditionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// A comparison of two integer values is next in priority.
		//Comparison returns Expression:
		//	Addition (({Less.left=current} "<" | {LessOrEqual.left=current} ("<=" | "≤") | {GreaterOrEqual.left=current} (">=" |
		//	"≥") | {Greater.left=current} ">") right=Addition)?;
		public ParserRule getRule() { return rule; }

		//Addition (({Less.left=current} "<" | {LessOrEqual.left=current} ("<=" | "≤") | {GreaterOrEqual.left=current} (">=" |
		//"≥") | {Greater.left=current} ">") right=Addition)?
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//(({Less.left=current} "<" | {LessOrEqual.left=current} ("<=" | "≤") | {GreaterOrEqual.left=current} (">=" | "≥") |
		//{Greater.left=current} ">") right=Addition)?
		public Group getGroup_1() { return cGroup_1; }

		//{Less.left=current} "<" | {LessOrEqual.left=current} ("<=" | "≤") | {GreaterOrEqual.left=current} (">=" | "≥") |
		//{Greater.left=current} ">"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Less.left=current} "<"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Less.left=current}
		public Action getLessLeftAction_1_0_0_0() { return cLessLeftAction_1_0_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_0_1() { return cLessThanSignKeyword_1_0_0_1; }

		//{LessOrEqual.left=current} ("<=" | "≤")
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{LessOrEqual.left=current}
		public Action getLessOrEqualLeftAction_1_0_1_0() { return cLessOrEqualLeftAction_1_0_1_0; }

		//"<=" | "≤"
		public Alternatives getAlternatives_1_0_1_1() { return cAlternatives_1_0_1_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1_1_0() { return cLessThanSignEqualsSignKeyword_1_0_1_1_0; }

		//"≤"
		public Keyword getLessThanOrEqualToKeyword_1_0_1_1_1() { return cLessThanOrEqualToKeyword_1_0_1_1_1; }

		//{GreaterOrEqual.left=current} (">=" | "≥")
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{GreaterOrEqual.left=current}
		public Action getGreaterOrEqualLeftAction_1_0_2_0() { return cGreaterOrEqualLeftAction_1_0_2_0; }

		//">=" | "≥"
		public Alternatives getAlternatives_1_0_2_1() { return cAlternatives_1_0_2_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_2_1_0() { return cGreaterThanSignEqualsSignKeyword_1_0_2_1_0; }

		//"≥"
		public Keyword getGreaterThanOrEqualToKeyword_1_0_2_1_1() { return cGreaterThanOrEqualToKeyword_1_0_2_1_1; }

		//{Greater.left=current} ">"
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_0_3_0() { return cGreaterLeftAction_1_0_3_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_3_1() { return cGreaterThanSignKeyword_1_0_3_1; }

		//right=Addition
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_1_0() { return cRightAdditionParserRuleCall_1_1_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cAdditionLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cSubtractionLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Next in priority are addition and subtraction
		//Addition returns Expression:
		//	Multiplication (({Addition.left=current} "+" | {Subtraction.left=current} "-") right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication (({Addition.left=current} "+" | {Subtraction.left=current} "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//(({Addition.left=current} "+" | {Subtraction.left=current} "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.left=current} "+" | {Subtraction.left=current} "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Addition.left=current} "+"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Addition.left=current}
		public Action getAdditionLeftAction_1_0_0_0() { return cAdditionLeftAction_1_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Subtraction.left=current} "-"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Subtraction.left=current}
		public Action getSubtractionLeftAction_1_0_1_0() { return cSubtractionLeftAction_1_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_1_0() { return cRightMultiplicationParserRuleCall_1_1_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryOperationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiplicationLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Alternatives cAlternatives_1_0_0_1 = (Alternatives)cGroup_1_0_0.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_0_0_1_0 = (Keyword)cAlternatives_1_0_0_1.eContents().get(0);
		private final Keyword cMiddleDotKeyword_1_0_0_1_1 = (Keyword)cAlternatives_1_0_0_1.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivisionLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Alternatives cAlternatives_1_0_1_1 = (Alternatives)cGroup_1_0_1.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0_1_1_0 = (Keyword)cAlternatives_1_0_1_1.eContents().get(0);
		private final Keyword cDivisionSignKeyword_1_0_1_1_1 = (Keyword)cAlternatives_1_0_1_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModulusLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryOperationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Next in priority are multiplication, division, and modulo.
		//Multiplication returns Expression:
		//	UnaryOperation (({Multiplication.left=current} ("*" | "·") | {Division.left=current} ("/" | "÷") |
		//	{Modulus.left=current} "%") right=UnaryOperation)*;
		public ParserRule getRule() { return rule; }

		//UnaryOperation (({Multiplication.left=current} ("*" | "·") | {Division.left=current} ("/" | "÷") |
		//{Modulus.left=current} "%") right=UnaryOperation)*
		public Group getGroup() { return cGroup; }

		//UnaryOperation
		public RuleCall getUnaryOperationParserRuleCall_0() { return cUnaryOperationParserRuleCall_0; }

		//(({Multiplication.left=current} ("*" | "·") | {Division.left=current} ("/" | "÷") | {Modulus.left=current} "%")
		//right=UnaryOperation)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.left=current} ("*" | "·") | {Division.left=current} ("/" | "÷") | {Modulus.left=current} "%"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Multiplication.left=current} ("*" | "·")
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Multiplication.left=current}
		public Action getMultiplicationLeftAction_1_0_0_0() { return cMultiplicationLeftAction_1_0_0_0; }

		//"*" | "·"
		public Alternatives getAlternatives_1_0_0_1() { return cAlternatives_1_0_0_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_1_0() { return cAsteriskKeyword_1_0_0_1_0; }

		//"·"
		public Keyword getMiddleDotKeyword_1_0_0_1_1() { return cMiddleDotKeyword_1_0_0_1_1; }

		//{Division.left=current} ("/" | "÷")
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Division.left=current}
		public Action getDivisionLeftAction_1_0_1_0() { return cDivisionLeftAction_1_0_1_0; }

		//"/" | "÷"
		public Alternatives getAlternatives_1_0_1_1() { return cAlternatives_1_0_1_1; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1_1_0() { return cSolidusKeyword_1_0_1_1_0; }

		//"÷"
		public Keyword getDivisionSignKeyword_1_0_1_1_1() { return cDivisionSignKeyword_1_0_1_1_1; }

		//{Modulus.left=current} "%"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Modulus.left=current}
		public Action getModulusLeftAction_1_0_2_0() { return cModulusLeftAction_1_0_2_0; }

		//"%"
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=UnaryOperation
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//UnaryOperation
		public RuleCall getRightUnaryOperationParserRuleCall_1_1_0() { return cRightUnaryOperationParserRuleCall_1_1_0; }
	}

	public class UnaryOperationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cNegationAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Alternatives cAlternatives_1_0_2_1 = (Alternatives)cGroup_1_0_2.eContents().get(1);
		private final Keyword cNotSignKeyword_1_0_2_1_0 = (Keyword)cAlternatives_1_0_2_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_0_2_1_1 = (Keyword)cAlternatives_1_0_2_1.eContents().get(1);
		private final Assignment cOperandAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandAtomicParserRuleCall_1_1_0 = (RuleCall)cOperandAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cArrayLengthAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cLengthKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cOperandAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cOperandAtomicParserRuleCall_2_3_0 = (RuleCall)cOperandAssignment_2_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		
		//// The unary operations (unary plus, unary minus, Boolean not) have second highest priority.
		//UnaryOperation returns Expression:
		//	Atomic | ({Plus} "-" | {Minus} "+" | {Negation} ("¬" | "!")) operand=Atomic | {ArrayLength} "length" "("
		//	operand=Atomic ")";
		public ParserRule getRule() { return rule; }

		//Atomic | ({Plus} "-" | {Minus} "+" | {Negation} ("¬" | "!")) operand=Atomic | {ArrayLength} "length" "(" operand=Atomic
		//")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_0() { return cAtomicParserRuleCall_0; }

		//({Plus} "-" | {Minus} "+" | {Negation} ("¬" | "!")) operand=Atomic
		public Group getGroup_1() { return cGroup_1; }

		//{Plus} "-" | {Minus} "+" | {Negation} ("¬" | "!")
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Plus} "-"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Plus}
		public Action getPlusAction_1_0_0_0() { return cPlusAction_1_0_0_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_0_1() { return cHyphenMinusKeyword_1_0_0_1; }

		//{Minus} "+"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus}
		public Action getMinusAction_1_0_1_0() { return cMinusAction_1_0_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_1_1() { return cPlusSignKeyword_1_0_1_1; }

		//{Negation} ("¬" | "!")
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Negation}
		public Action getNegationAction_1_0_2_0() { return cNegationAction_1_0_2_0; }

		//"¬" | "!"
		public Alternatives getAlternatives_1_0_2_1() { return cAlternatives_1_0_2_1; }

		//"¬"
		public Keyword getNotSignKeyword_1_0_2_1_0() { return cNotSignKeyword_1_0_2_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_0_2_1_1() { return cExclamationMarkKeyword_1_0_2_1_1; }

		//operand=Atomic
		public Assignment getOperandAssignment_1_1() { return cOperandAssignment_1_1; }

		//Atomic
		public RuleCall getOperandAtomicParserRuleCall_1_1_0() { return cOperandAtomicParserRuleCall_1_1_0; }

		//{ArrayLength} "length" "(" operand=Atomic ")"
		public Group getGroup_2() { return cGroup_2; }

		//{ArrayLength}
		public Action getArrayLengthAction_2_0() { return cArrayLengthAction_2_0; }

		//"length"
		public Keyword getLengthKeyword_2_1() { return cLengthKeyword_2_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_2() { return cLeftParenthesisKeyword_2_2; }

		//operand=Atomic
		public Assignment getOperandAssignment_2_3() { return cOperandAssignment_2_3; }

		//Atomic
		public RuleCall getOperandAtomicParserRuleCall_2_3_0() { return cOperandAtomicParserRuleCall_2_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_4() { return cRightParenthesisKeyword_2_4; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cIntegerLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueNUMBERTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cValueBOOLTerminalRuleCall_2_1_0 = (RuleCall)cValueAssignment_2_1.eContents().get(0);
		private final RuleCall cVariableReferenceParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//// An atomic value in an Expression is either
		////  - a function call or
		////  - a number or
		////  - a Boolean literal or
		////  - a reference to a variable
		////  - a whole new Expression in parentheses.
		//Atomic returns Expression:
		//	FunctionCall | {IntegerLiteral} value=NUMBER | {BooleanLiteral} value=BOOL | VariableReference | "(" Expression ")";
		public ParserRule getRule() { return rule; }

		//FunctionCall | {IntegerLiteral} value=NUMBER | {BooleanLiteral} value=BOOL | VariableReference | "(" Expression ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_0() { return cFunctionCallParserRuleCall_0; }

		//{IntegerLiteral} value=NUMBER
		public Group getGroup_1() { return cGroup_1; }

		//{IntegerLiteral}
		public Action getIntegerLiteralAction_1_0() { return cIntegerLiteralAction_1_0; }

		//value=NUMBER
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//NUMBER
		public RuleCall getValueNUMBERTerminalRuleCall_1_1_0() { return cValueNUMBERTerminalRuleCall_1_1_0; }

		//{BooleanLiteral} value=BOOL
		public Group getGroup_2() { return cGroup_2; }

		//{BooleanLiteral}
		public Action getBooleanLiteralAction_2_0() { return cBooleanLiteralAction_2_0; }

		//value=BOOL
		public Assignment getValueAssignment_2_1() { return cValueAssignment_2_1; }

		//BOOL
		public RuleCall getValueBOOLTerminalRuleCall_2_1_0() { return cValueBOOLTerminalRuleCall_2_1_0; }

		//VariableReference
		public RuleCall getVariableReferenceParserRuleCall_3() { return cVariableReferenceParserRuleCall_3; }

		//"(" Expression ")"
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}

	public class VariableReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableReferenceAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVariableVariableDeclarationCrossReference_1_0 = (CrossReference)cVariableAssignment_1.eContents().get(0);
		private final RuleCall cVariableVariableDeclarationIDTerminalRuleCall_1_0_1 = (RuleCall)cVariableVariableDeclarationCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cIndexAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIndexExpressionParserRuleCall_2_1_0 = (RuleCall)cIndexAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//// A variable reference is used to denote the current content of a variable. 
		//VariableReference:
		//	{VariableReference} variable=[VariableDeclaration] ("[" index=Expression "]")?;
		public ParserRule getRule() { return rule; }

		//{VariableReference} variable=[VariableDeclaration] ("[" index=Expression "]")?
		public Group getGroup() { return cGroup; }

		//{VariableReference}
		public Action getVariableReferenceAction_0() { return cVariableReferenceAction_0; }

		//variable=[VariableDeclaration]
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//[VariableDeclaration]
		public CrossReference getVariableVariableDeclarationCrossReference_1_0() { return cVariableVariableDeclarationCrossReference_1_0; }

		//ID
		public RuleCall getVariableVariableDeclarationIDTerminalRuleCall_1_0_1() { return cVariableVariableDeclarationIDTerminalRuleCall_1_0_1; }

		//("[" index=Expression "]")?
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//index=Expression
		public Assignment getIndexAssignment_2_1() { return cIndexAssignment_2_1; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_2_1_0() { return cIndexExpressionParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}
	
	
	private ProgramElements pProgram;
	private TerminalRule tWS;
	private TerminalRule tNL;
	private TerminalRule tSL_COMMENT;
	private TerminalRule tNUMBER;
	private TerminalRule tINT;
	private TerminalRule tBOOL;
	private AxiomElements pAxiom;
	private BlockElements pBlock;
	private BracedBlockElements pBracedBlock;
	private StatementElements pStatement;
	private ReturnStatementElements pReturnStatement;
	private WhileStatementElements pWhileStatement;
	private InvariantElements pInvariant;
	private IfStatementElements pIfStatement;
	private FunctionDeclarationElements pFunctionDeclaration;
	private RequireElements pRequire;
	private EnsureElements pEnsure;
	private ParameterElements pParameter;
	private TypeElements pType;
	private PrimitiveTypeElements pPrimitiveType;
	private ArrayTypeElements pArrayType;
	private FunctionCallElements pFunctionCall;
	private AnnotationElements pAnnotation;
	private QuantifiedExpressionElements pQuantifiedExpression;
	private VariableDeclarationElements pVariableDeclaration;
	private AssignmentElements pAssignment;
	private ExpressionElements pExpression;
	private BooleanOrElements pBooleanOr;
	private BooleanAndElements pBooleanAnd;
	private EqualsComparisonElements pEqualsComparison;
	private ComparisonElements pComparison;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private UnaryOperationElements pUnaryOperation;
	private AtomicElements pAtomic;
	private VariableReferenceElements pVariableReference;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public WorthwhileGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// A program consists of a sequence of statements and/or function declarations.
	//Program:
	//	{Program} NL* // Newline at the beginning of the file is allowed.
	//	((axioms+=Axiom | functionDeclarations+=FunctionDeclaration) NL+)* mainBlock= // FIXME: Newline at end of file?
	//	Block;
	public ProgramElements getProgramAccess() {
		return (pProgram != null) ? pProgram : (pProgram = new ProgramElements());
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//// Override the whitespace rules: Disallow line breaks as whitespace since we want to use them to separate statements 
	//terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//// A newline consists of at least one '\n'.
	//terminal NL:
	//	("\r" | "\n" | WS)* "\n" WS*;
	public TerminalRule getNLRule() {
		return (tNL != null) ? tNL : (tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NL"));
	} 

	//// A single line comment includes everything from // to the next newline, but not the newline itself.
	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")*;
	public TerminalRule getSL_COMMENTRule() {
		return (tSL_COMMENT != null) ? tSL_COMMENT : (tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_COMMENT"));
	} 

	//// A number can be any integer.
	//terminal NUMBER returns ecore::EBigInteger:
	//	"-"? "0".."9"+;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//// We are using the terminal NUMBER instead of INT, so we have to redefine INT because it matches the same pattern as NUMBER.
	//// Else the parser will throw an error.
	//terminal INT returns ecore::EInt:
	//	"%%% DONT USE THIS ANYMORE %%%";
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//// BOOL matches a boolean value. 
	//terminal BOOL returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLRule() {
		return (tBOOL != null) ? tBOOL : (tBOOL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOL"));
	} 

	//// An axiom is declared at the top level in the program and is valid for all annotations.
	//Axiom:
	//	"_axiom" expression=Expression;
	public AxiomElements getAxiomAccess() {
		return (pAxiom != null) ? pAxiom : (pAxiom = new AxiomElements());
	}
	
	public ParserRule getAxiomRule() {
		return getAxiomAccess().getRule();
	}

	//// A block consists of one or multiple statements.
	//Block:
	//	{Block} (statements+=Statement NL+)*;
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// This is a block enclosed in curly braces
	//BracedBlock returns Block:
	//	{Block} "{" NL* (statements+=Statement NL+)* "}";
	public BracedBlockElements getBracedBlockAccess() {
		return (pBracedBlock != null) ? pBracedBlock : (pBracedBlock = new BracedBlockElements());
	}
	
	public ParserRule getBracedBlockRule() {
		return getBracedBlockAccess().getRule();
	}

	//// A statement is everything that can be executed in the program.
	//Statement:
	//	VariableDeclaration | Assignment | BracedBlock | Annotation | IfStatement | WhileStatement | ReturnStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// A return statement returns a value from a function.
	//ReturnStatement:
	//	"return" returnValue=Expression;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//// A while statement specifies a while loop.
	//WhileStatement returns Loop:
	//	"while" condition=Expression invariants+=Invariant* body=BracedBlock;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	//// An invariant can be used to specify the invariants of a WHILE loop.
	//Invariant:
	//	"_invariant" expression=Expression NL+;
	public InvariantElements getInvariantAccess() {
		return (pInvariant != null) ? pInvariant : (pInvariant = new InvariantElements());
	}
	
	public ParserRule getInvariantRule() {
		return getInvariantAccess().getRule();
	}

	//// An if statement specifies a conditional Expression.
	//IfStatement returns Conditional:
	//	"if" condition=Expression trueBlock=BracedBlock ("else" falseBlock=BracedBlock)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//// A function declaration declares a function name, parameters, return type, and function body.
	//FunctionDeclaration:
	//	"function" returnType=Type name=ID "(" (parameters+=Parameter ("," parameters+=Parameter)*)? ")" NL*
	//	(preconditions+=Require | postconditions+=Ensure)* body=BracedBlock;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//// Preconditions are specified using the _requires keyword.
	//Require returns Precondition:
	//	"_requires" expression=Expression NL+;
	public RequireElements getRequireAccess() {
		return (pRequire != null) ? pRequire : (pRequire = new RequireElements());
	}
	
	public ParserRule getRequireRule() {
		return getRequireAccess().getRule();
	}

	//// Preconditions are specified using the _ensures keyword.
	//Ensure returns Postcondition:
	//	"_ensures" expression=Expression NL+;
	public EnsureElements getEnsureAccess() {
		return (pEnsure != null) ? pEnsure : (pEnsure = new EnsureElements());
	}
	
	public ParserRule getEnsureRule() {
		return getEnsureAccess().getRule();
	}

	//// A function parameter definition describes a single parameter (type and name) accepted by a function or introduced by a quantifier
	//Parameter returns VariableDeclaration:
	//	{VariableDeclaration} type=Type name=ID;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//// A type can either be a primitive type or an array of a primitive type
	//Type:
	//	PrimitiveType | ArrayType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// A primitive type represents a variable type that can hold one value.
	//PrimitiveType:
	//	{IntegerType} "Integer" | {BooleanType} "Boolean";
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return (pPrimitiveType != null) ? pPrimitiveType : (pPrimitiveType = new PrimitiveTypeElements());
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}

	//// An array type represents an array of a primitive type.
	//ArrayType:
	//	{ArrayType} baseType=PrimitiveType "[" size=Expression "]";
	public ArrayTypeElements getArrayTypeAccess() {
		return (pArrayType != null) ? pArrayType : (pArrayType = new ArrayTypeElements());
	}
	
	public ParserRule getArrayTypeRule() {
		return getArrayTypeAccess().getRule();
	}

	//// A function call simply calls a function without returning a value.
	//FunctionCall:
	//	function=[FunctionDeclaration] "(" actuals+=Expression? ("," actuals+=Expression)* ")";
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//// An annotation is used to specify assertions and assumptions.
	//Annotation:
	//	({Assertion} "_assert" | {Assumption} "_assume") expression=Expression;
	public AnnotationElements getAnnotationAccess() {
		return (pAnnotation != null) ? pAnnotation : (pAnnotation = new AnnotationElements());
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// A quantified Expression is an Expression optionally preceded by some quantifier definitions.
	//QuantifiedExpression:
	//	(({ForAllQuantifier} ("forall" | "∀") | {ExistsQuantifier} ("exists" | "∃")) parameter=Parameter (","
	//	condition=Expression)?) (expression=QuantifiedExpression | ":" expression=Expression);
	public QuantifiedExpressionElements getQuantifiedExpressionAccess() {
		return (pQuantifiedExpression != null) ? pQuantifiedExpression : (pQuantifiedExpression = new QuantifiedExpressionElements());
	}
	
	public ParserRule getQuantifiedExpressionRule() {
		return getQuantifiedExpressionAccess().getRule();
	}

	//// A variable declaration declares a new variable and assigns it a value.
	//VariableDeclaration:
	//	{VariableDeclaration} type=Type name=ID ":=" initialValue=Expression;
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return (pVariableDeclaration != null) ? pVariableDeclaration : (pVariableDeclaration = new VariableDeclarationElements());
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	//// An assignment assigns a value to a variable.
	//Assignment:
	//	variable=VariableReference ":=" value=Expression;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//// An Expression is based on operator precedence. Each "level" of Expressions means one level of operator precedence,
	//// where the last operation specified has the highest priority. In the same level, operators are evaluated from left to right.
	//Expression:
	//	QuantifiedExpression | BooleanOr;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// The boolean or has the lowest priority.
	//BooleanOr returns Expression:
	//	BooleanAnd ({Disjunction.left=current} ("∨" | "||") right=BooleanAnd)?;
	public BooleanOrElements getBooleanOrAccess() {
		return (pBooleanOr != null) ? pBooleanOr : (pBooleanOr = new BooleanOrElements());
	}
	
	public ParserRule getBooleanOrRule() {
		return getBooleanOrAccess().getRule();
	}

	//// The boolean and has second lowest priority.
	//BooleanAnd returns Expression:
	//	EqualsComparison ({Conjunction.left=current} ("∧" | "&&") right=EqualsComparison)?;
	public BooleanAndElements getBooleanAndAccess() {
		return (pBooleanAnd != null) ? pBooleanAnd : (pBooleanAnd = new BooleanAndElements());
	}
	
	public ParserRule getBooleanAndRule() {
		return getBooleanAndAccess().getRule();
	}

	//// The equal and unequal comparisons are next in priority.
	//EqualsComparison returns Expression:
	//	Comparison (({Equal.left=current} "=" | {Unequal.left=current} ("!=" | "≠")) right=Comparison)?;
	public EqualsComparisonElements getEqualsComparisonAccess() {
		return (pEqualsComparison != null) ? pEqualsComparison : (pEqualsComparison = new EqualsComparisonElements());
	}
	
	public ParserRule getEqualsComparisonRule() {
		return getEqualsComparisonAccess().getRule();
	}

	//// A comparison of two integer values is next in priority.
	//Comparison returns Expression:
	//	Addition (({Less.left=current} "<" | {LessOrEqual.left=current} ("<=" | "≤") | {GreaterOrEqual.left=current} (">=" |
	//	"≥") | {Greater.left=current} ">") right=Addition)?;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//// Next in priority are addition and subtraction
	//Addition returns Expression:
	//	Multiplication (({Addition.left=current} "+" | {Subtraction.left=current} "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//// Next in priority are multiplication, division, and modulo.
	//Multiplication returns Expression:
	//	UnaryOperation (({Multiplication.left=current} ("*" | "·") | {Division.left=current} ("/" | "÷") |
	//	{Modulus.left=current} "%") right=UnaryOperation)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//// The unary operations (unary plus, unary minus, Boolean not) have second highest priority.
	//UnaryOperation returns Expression:
	//	Atomic | ({Plus} "-" | {Minus} "+" | {Negation} ("¬" | "!")) operand=Atomic | {ArrayLength} "length" "("
	//	operand=Atomic ")";
	public UnaryOperationElements getUnaryOperationAccess() {
		return (pUnaryOperation != null) ? pUnaryOperation : (pUnaryOperation = new UnaryOperationElements());
	}
	
	public ParserRule getUnaryOperationRule() {
		return getUnaryOperationAccess().getRule();
	}

	//// An atomic value in an Expression is either
	////  - a function call or
	////  - a number or
	////  - a Boolean literal or
	////  - a reference to a variable
	////  - a whole new Expression in parentheses.
	//Atomic returns Expression:
	//	FunctionCall | {IntegerLiteral} value=NUMBER | {BooleanLiteral} value=BOOL | VariableReference | "(" Expression ")";
	public AtomicElements getAtomicAccess() {
		return (pAtomic != null) ? pAtomic : (pAtomic = new AtomicElements());
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	//// A variable reference is used to denote the current content of a variable. 
	//VariableReference:
	//	{VariableReference} variable=[VariableDeclaration] ("[" index=Expression "]")?;
	public VariableReferenceElements getVariableReferenceAccess() {
		return (pVariableReference != null) ? pVariableReference : (pVariableReference = new VariableReferenceElements());
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
