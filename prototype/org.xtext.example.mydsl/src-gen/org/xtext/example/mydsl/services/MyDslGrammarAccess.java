/*
* generated by Xtext
*/

package org.xtext.example.mydsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cStatementsAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0 = (RuleCall)cStatementsAssignment_0.eContents().get(0);
		private final Assignment cFunctionsAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionsFunctionDeclarationParserRuleCall_1_0 = (RuleCall)cFunctionsAssignment_1.eContents().get(0);
		
		//// A program consists of a sequence of statements and/or function declarations.
		//Model:
		//	(statements+=Statement | functions+=FunctionDeclaration)*;
		public ParserRule getRule() { return rule; }

		//(statements+=Statement | functions+=FunctionDeclaration)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//statements+=Statement
		public Assignment getStatementsAssignment_0() { return cStatementsAssignment_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0_0() { return cStatementsStatementParserRuleCall_0_0; }

		//functions+=FunctionDeclaration
		public Assignment getFunctionsAssignment_1() { return cFunctionsAssignment_1; }

		//FunctionDeclaration
		public RuleCall getFunctionsFunctionDeclarationParserRuleCall_1_0() { return cFunctionsFunctionDeclarationParserRuleCall_1_0; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// Override the whitespace rules since we do not allow newlines to count as whitespace.
		//// terminal WS : (' '|'\t'|'\r')+;
		//// A block consists of multiple statement enclosed in curly brackets.
		//Block:
		//	{Block} "{" statements+=Statement* "}";
		public ParserRule getRule() { return rule; }

		//{Block} "{" statements+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIfStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cWhileStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cReturnStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//// A statement is everything that can be executed in the program.
		//Statement:
		//	VariableDeclaration // ('\n' | MyEof) 
		//	| Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement;
		public ParserRule getRule() { return rule; }

		//VariableDeclaration // ('\n' | MyEof) 
		//| Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }

		//Annotation
		public RuleCall getAnnotationParserRuleCall_3() { return cAnnotationParserRuleCall_3; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_4() { return cFunctionCallParserRuleCall_4; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_5() { return cIfStatementParserRuleCall_5; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_6() { return cWhileStatementParserRuleCall_6; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_7() { return cReturnStatementParserRuleCall_7; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnExprExprParserRuleCall_1_0 = (RuleCall)cReturnExprAssignment_1.eContents().get(0);
		
		/// *NoOp:
		//	{NoOp}
		//;* / // A return statement returns a value from a function.
		//ReturnStatement:
		//	"return" returnExpr=Expr;
		public ParserRule getRule() { return rule; }

		//"return" returnExpr=Expr
		public Group getGroup() { return cGroup; }

		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }

		//returnExpr=Expr
		public Assignment getReturnExprAssignment_1() { return cReturnExprAssignment_1; }

		//Expr
		public RuleCall getReturnExprExprParserRuleCall_1_0() { return cReturnExprExprParserRuleCall_1_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A while statement specifies a while loop.
		//WhileStatement:
		//	{WhileStatement} "while";
		public ParserRule getRule() { return rule; }

		//{WhileStatement} "while"
		public Group getGroup() { return cGroup; }

		//{WhileStatement}
		public Action getWhileStatementAction_0() { return cWhileStatementAction_0; }

		//"while"
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// An if statement specifies a conditional expression.
		//IfStatement:
		//	{IfStatement} "if";
		public ParserRule getRule() { return rule; }

		//{IfStatement} "if"
		public Group getGroup() { return cGroup; }

		//{IfStatement}
		public Action getIfStatementAction_0() { return cIfStatementAction_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnTypeTypeParserRuleCall_1_0 = (RuleCall)cReturnTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cParamsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_4_0_0 = (RuleCall)cParamsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cParamsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_4_1_1_0 = (RuleCall)cParamsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyBlockParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		
		//// A function declaration declares a function name, parameters, return type, and function body.
		//FunctionDeclaration:
		//	"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block;
		public ParserRule getRule() { return rule; }

		//"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_1() { return cReturnTypeAssignment_1; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_1_0() { return cReturnTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_4() { return cGroup_4; }

		//params+=Parameter
		public Assignment getParamsAssignment_4_0() { return cParamsAssignment_4_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_4_0_0() { return cParamsParameterParserRuleCall_4_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_4_1_1() { return cParamsAssignment_4_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_4_1_1_0() { return cParamsParameterParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//body=Block
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_6_0() { return cBodyBlockParserRuleCall_6_0; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//Parameter returns Symbol:
		//	{Parameter} type=Type name=ID;
		public ParserRule getRule() { return rule; }

		//{Parameter} type=Type name=ID
		public Group getGroup() { return cGroup; }

		//{Parameter}
		public Action getParameterAction_0() { return cParameterAction_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A type can either be a primitive type or an array of a primitive type
		//Type:
		//	PrimitiveType | ArrayType;
		public ParserRule getRule() { return rule; }

		//PrimitiveType | ArrayType
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0() { return cPrimitiveTypeParserRuleCall_0; }

		//ArrayType
		public RuleCall getArrayTypeParserRuleCall_1() { return cArrayTypeParserRuleCall_1; }
	}

	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A primitive type represents a variable type that can hold one value.
		//PrimitiveType:
		//	IntType | BoolType;
		public ParserRule getRule() { return rule; }

		//IntType | BoolType
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntType
		public RuleCall getIntTypeParserRuleCall_0() { return cIntTypeParserRuleCall_0; }

		//BoolType
		public RuleCall getBoolTypeParserRuleCall_1() { return cBoolTypeParserRuleCall_1; }
	}

	public class IntTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIntKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// An integer type represents an arbitrarily large integer.
		//IntType:
		//	{IntType} "int";
		public ParserRule getRule() { return rule; }

		//{IntType} "int"
		public Group getGroup() { return cGroup; }

		//{IntType}
		public Action getIntTypeAction_0() { return cIntTypeAction_0; }

		//"int"
		public Keyword getIntKeyword_1() { return cIntKeyword_1; }
	}

	public class BoolTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBoolKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A bool type represents a Boolean value.
		//BoolType:
		//	{BoolType} "bool";
		public ParserRule getRule() { return rule; }

		//{BoolType} "bool"
		public Group getGroup() { return cGroup; }

		//{BoolType}
		public Action getBoolTypeAction_0() { return cBoolTypeAction_0; }

		//"bool"
		public Keyword getBoolKeyword_1() { return cBoolKeyword_1; }
	}

	public class ArrayTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArrayTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBaseTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBaseTypePrimitiveTypeParserRuleCall_1_0 = (RuleCall)cBaseTypeAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// An array type represents an array of a primitive type.
		//ArrayType:
		//	{ArrayType} baseType=PrimitiveType "[" "]";
		public ParserRule getRule() { return rule; }

		//{ArrayType} baseType=PrimitiveType "[" "]"
		public Group getGroup() { return cGroup; }

		//{ArrayType}
		public Action getArrayTypeAction_0() { return cArrayTypeAction_0; }

		//baseType=PrimitiveType
		public Assignment getBaseTypeAssignment_1() { return cBaseTypeAssignment_1; }

		//PrimitiveType
		public RuleCall getBaseTypePrimitiveTypeParserRuleCall_1_0() { return cBaseTypePrimitiveTypeParserRuleCall_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFunctionCallStatementKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A function call simply calls a function without returning a value. 
		//FunctionCall:
		//	{FunctionCall} "functionCallStatement";
		public ParserRule getRule() { return rule; }

		//{FunctionCall} "functionCallStatement"
		public Group getGroup() { return cGroup; }

		//{FunctionCall}
		public Action getFunctionCallAction_0() { return cFunctionCallAction_0; }

		//"functionCallStatement"
		public Keyword getFunctionCallStatementKeyword_1() { return cFunctionCallStatementKeyword_1; }
	}

	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Annotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAnnotationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTODO5Keyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// An annotation is used to specify assertions and assumptions.
		//Annotation:
		//	{Annotation} "TODO5";
		public ParserRule getRule() { return rule; }

		//{Annotation} "TODO5"
		public Group getGroup() { return cGroup; }

		//{Annotation}
		public Action getAnnotationAction_0() { return cAnnotationAction_0; }

		//"TODO5"
		public Keyword getTODO5Keyword_1() { return cTODO5Keyword_1; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitialValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitialValueExprParserRuleCall_2_1_0 = (RuleCall)cInitialValueAssignment_2_1.eContents().get(0);
		
		//// A variable declaration declares a new variable and optionally assigns it a value.
		//VariableDeclaration:
		//	type=Type name=ID (":=" initialValue=Expr);
		public ParserRule getRule() { return rule; }

		//type=Type name=ID (":=" initialValue=Expr)
		public Group getGroup() { return cGroup; }

		//type=Type
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_0_0() { return cTypeTypeParserRuleCall_0_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":=" initialValue=Expr
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//initialValue=Expr
		public Assignment getInitialValueAssignment_2_1() { return cInitialValueAssignment_2_1; }

		//Expr
		public RuleCall getInitialValueExprParserRuleCall_2_1_0() { return cInitialValueExprParserRuleCall_2_1_0; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVariableIDTerminalRuleCall_0_0 = (RuleCall)cVariableAssignment_0.eContents().get(0);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// An assignment assigns a value to a variable.
		//Assignment:
		//	variable=ID ":=" value=Expr;
		public ParserRule getRule() { return rule; }

		//variable=ID ":=" value=Expr
		public Group getGroup() { return cGroup; }

		//variable=ID
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//ID
		public RuleCall getVariableIDTerminalRuleCall_0_0() { return cVariableIDTerminalRuleCall_0_0; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//value=Expr
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expr
		public RuleCall getValueExprParserRuleCall_2_0() { return cValueExprParserRuleCall_2_0; }
	}

	public class ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expr");
		private final RuleCall cComparisonParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expr:
		//	Comparison;
		public ParserRule getRule() { return rule; }

		//Comparison
		public RuleCall getComparisonParserRuleCall() { return cComparisonParserRuleCall; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualsLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeComparisonTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison returns Expression:
		//	Addition ({Equals.left=current} type=ComparisonType right=Addition)?;
		public ParserRule getRule() { return rule; }

		//Addition ({Equals.left=current} type=ComparisonType right=Addition)?
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//({Equals.left=current} type=ComparisonType right=Addition)?
		public Group getGroup_1() { return cGroup_1; }

		//{Equals.left=current}
		public Action getEqualsLeftAction_1_0() { return cEqualsLeftAction_1_0; }

		//type=ComparisonType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//ComparisonType
		public RuleCall getTypeComparisonTypeParserRuleCall_1_1_0() { return cTypeComparisonTypeParserRuleCall_1_1_0; }

		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}

	public class ComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLessComparisonTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLessOrEqualComparisonTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEqualComparisonTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGreaterOrEqualComparisonTypeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGreaterComparisonTypeParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//ComparisonType:
		//	LessComparisonType | LessOrEqualComparisonType | EqualComparisonType | GreaterOrEqualComparisonType |
		//	GreaterComparisonType;
		public ParserRule getRule() { return rule; }

		//LessComparisonType | LessOrEqualComparisonType | EqualComparisonType | GreaterOrEqualComparisonType |
		//GreaterComparisonType
		public Alternatives getAlternatives() { return cAlternatives; }

		//LessComparisonType
		public RuleCall getLessComparisonTypeParserRuleCall_0() { return cLessComparisonTypeParserRuleCall_0; }

		//LessOrEqualComparisonType
		public RuleCall getLessOrEqualComparisonTypeParserRuleCall_1() { return cLessOrEqualComparisonTypeParserRuleCall_1; }

		//EqualComparisonType
		public RuleCall getEqualComparisonTypeParserRuleCall_2() { return cEqualComparisonTypeParserRuleCall_2; }

		//GreaterOrEqualComparisonType
		public RuleCall getGreaterOrEqualComparisonTypeParserRuleCall_3() { return cGreaterOrEqualComparisonTypeParserRuleCall_3; }

		//GreaterComparisonType
		public RuleCall getGreaterComparisonTypeParserRuleCall_4() { return cGreaterComparisonTypeParserRuleCall_4; }
	}

	public class LessComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LessComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLessComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LessComparisonType:
		//	{LessComparisonType} "<";
		public ParserRule getRule() { return rule; }

		//{LessComparisonType} "<"
		public Group getGroup() { return cGroup; }

		//{LessComparisonType}
		public Action getLessComparisonTypeAction_0() { return cLessComparisonTypeAction_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }
	}

	public class LessOrEqualComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LessOrEqualComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLessOrEqualComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cLessThanOrEqualToKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//LessOrEqualComparisonType:
		//	{LessOrEqualComparisonType} ("<=" | "≤");
		public ParserRule getRule() { return rule; }

		//{LessOrEqualComparisonType} ("<=" | "≤")
		public Group getGroup() { return cGroup; }

		//{LessOrEqualComparisonType}
		public Action getLessOrEqualComparisonTypeAction_0() { return cLessOrEqualComparisonTypeAction_0; }

		//"<=" | "≤"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0() { return cLessThanSignEqualsSignKeyword_1_0; }

		//"≤"
		public Keyword getLessThanOrEqualToKeyword_1_1() { return cLessThanOrEqualToKeyword_1_1; }
	}

	public class EqualComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cEqualComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//EqualComparisonType:
		//	{EqualComparisonType} "=";
		public ParserRule getRule() { return rule; }

		//{EqualComparisonType} "="
		public Group getGroup() { return cGroup; }

		//{EqualComparisonType}
		public Action getEqualComparisonTypeAction_0() { return cEqualComparisonTypeAction_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
	}

	public class GreaterOrEqualComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GreaterOrEqualComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGreaterOrEqualComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cGreaterThanOrEqualToKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//GreaterOrEqualComparisonType:
		//	{GreaterOrEqualComparisonType} (">=" | "≥");
		public ParserRule getRule() { return rule; }

		//{GreaterOrEqualComparisonType} (">=" | "≥")
		public Group getGroup() { return cGroup; }

		//{GreaterOrEqualComparisonType}
		public Action getGreaterOrEqualComparisonTypeAction_0() { return cGreaterOrEqualComparisonTypeAction_0; }

		//">=" | "≥"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0() { return cGreaterThanSignEqualsSignKeyword_1_0; }

		//"≥"
		public Keyword getGreaterThanOrEqualToKeyword_1_1() { return cGreaterThanOrEqualToKeyword_1_1; }
	}

	public class GreaterComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GreaterComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGreaterComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//GreaterComparisonType:
		//	{GreaterComparisonType} ">";
		public ParserRule getRule() { return rule; }

		//{GreaterComparisonType} ">"
		public Group getGroup() { return cGroup; }

		//{GreaterComparisonType}
		public Action getGreaterComparisonTypeAction_0() { return cGreaterComparisonTypeAction_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1() { return cGreaterThanSignKeyword_1; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns Expression:
		//	Multiplication ({Plus.left=current} "+" right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication ({Plus.left=current} "+" right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Plus.left=current} "+" right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0() { return cPlusLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPostfixOperatorsParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPostfixOperatorsParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//	PostfixOperators ({Multi.left=current} "*" right=PostfixOperators)*;
		public ParserRule getRule() { return rule; }

		//PostfixOperators ({Multi.left=current} "*" right=PostfixOperators)*
		public Group getGroup() { return cGroup; }

		//PostfixOperators
		public RuleCall getPostfixOperatorsParserRuleCall_0() { return cPostfixOperatorsParserRuleCall_0; }

		//({Multi.left=current} "*" right=PostfixOperators)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0() { return cMultiLeftAction_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }

		//right=PostfixOperators
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PostfixOperators
		public RuleCall getRightPostfixOperatorsParserRuleCall_1_2_0() { return cRightPostfixOperatorsParserRuleCall_1_2_0; }
	}

	public class PostfixOperatorsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostfixOperators");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrayAccessExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIndexAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIndexExprParserRuleCall_1_2_0 = (RuleCall)cIndexAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//PostfixOperators returns Expression:
		//	Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?;
		public ParserRule getRule() { return rule; }

		//Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?
		public Group getGroup() { return cGroup; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_0() { return cAtomicParserRuleCall_0; }

		//({ArrayAccess.expr=current} "[" index=Expr "]")?
		public Group getGroup_1() { return cGroup_1; }

		//{ArrayAccess.expr=current}
		public Action getArrayAccessExprAction_1_0() { return cArrayAccessExprAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//index=Expr
		public Assignment getIndexAssignment_1_2() { return cIndexAssignment_1_2; }

		//Expr
		public RuleCall getIndexExprParserRuleCall_1_2_0() { return cIndexExprParserRuleCall_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cSymbolRefAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cSymbolAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final CrossReference cSymbolSymbolCrossReference_0_1_0 = (CrossReference)cSymbolAssignment_0_1.eContents().get(0);
		private final RuleCall cSymbolSymbolIDTerminalRuleCall_0_1_0_1 = (RuleCall)cSymbolSymbolCrossReference_0_1_0.eContents().get(1);
		private final Group cGroup_0_2 = (Group)cGroup_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_0_2_0 = (Keyword)cGroup_0_2.eContents().get(0);
		private final Assignment cActualsAssignment_0_2_1 = (Assignment)cGroup_0_2.eContents().get(1);
		private final RuleCall cActualsExprParserRuleCall_0_2_1_0 = (RuleCall)cActualsAssignment_0_2_1.eContents().get(0);
		private final Group cGroup_0_2_2 = (Group)cGroup_0_2.eContents().get(2);
		private final Keyword cCommaKeyword_0_2_2_0 = (Keyword)cGroup_0_2_2.eContents().get(0);
		private final Assignment cActualsAssignment_0_2_2_1 = (Assignment)cGroup_0_2_2.eContents().get(1);
		private final RuleCall cActualsExprParserRuleCall_0_2_2_1_0 = (RuleCall)cActualsAssignment_0_2_2_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_2_3 = (Keyword)cGroup_0_2.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumberLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cBooleanLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// An atomic value in an expression is either
		////  - a function call or
		////  - a number or
		////  - a Boolean literal.
		//Atomic returns Expression:
		//	{SymbolRef} symbol=[Symbol] ("(" actuals+=Expr? ("," actuals+=Expr)* ")")? / * function call * / / * number * / |
		//	{NumberLiteral} value=INT | / * Boolean literal * / BooleanLiteral;
		public ParserRule getRule() { return rule; }

		//{SymbolRef} symbol=[Symbol] ("(" actuals+=Expr? ("," actuals+=Expr)* ")")? / * function call * / / * number * / |
		//{NumberLiteral} value=INT | / * Boolean literal * / BooleanLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//{SymbolRef} symbol=[Symbol] ("(" actuals+=Expr? ("," actuals+=Expr)* ")")?
		public Group getGroup_0() { return cGroup_0; }

		//{SymbolRef}
		public Action getSymbolRefAction_0_0() { return cSymbolRefAction_0_0; }

		//symbol=[Symbol]
		public Assignment getSymbolAssignment_0_1() { return cSymbolAssignment_0_1; }

		//[Symbol]
		public CrossReference getSymbolSymbolCrossReference_0_1_0() { return cSymbolSymbolCrossReference_0_1_0; }

		//ID
		public RuleCall getSymbolSymbolIDTerminalRuleCall_0_1_0_1() { return cSymbolSymbolIDTerminalRuleCall_0_1_0_1; }

		//("(" actuals+=Expr? ("," actuals+=Expr)* ")")?
		public Group getGroup_0_2() { return cGroup_0_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_2_0() { return cLeftParenthesisKeyword_0_2_0; }

		//actuals+=Expr?
		public Assignment getActualsAssignment_0_2_1() { return cActualsAssignment_0_2_1; }

		//Expr
		public RuleCall getActualsExprParserRuleCall_0_2_1_0() { return cActualsExprParserRuleCall_0_2_1_0; }

		//("," actuals+=Expr)*
		public Group getGroup_0_2_2() { return cGroup_0_2_2; }

		//","
		public Keyword getCommaKeyword_0_2_2_0() { return cCommaKeyword_0_2_2_0; }

		//actuals+=Expr
		public Assignment getActualsAssignment_0_2_2_1() { return cActualsAssignment_0_2_2_1; }

		//Expr
		public RuleCall getActualsExprParserRuleCall_0_2_2_1_0() { return cActualsExprParserRuleCall_0_2_2_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2_3() { return cRightParenthesisKeyword_0_2_3; }

		//{NumberLiteral} value=INT
		public Group getGroup_1() { return cGroup_1; }

		//{NumberLiteral}
		public Action getNumberLiteralAction_1_0() { return cNumberLiteralAction_1_0; }

		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }

		/// * Boolean literal * / BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_2() { return cBooleanLiteralParserRuleCall_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTrueLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFalseLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A Boolean literal is either "true" or "false"
		//BooleanLiteral:
		//	TrueLiteral | FalseLiteral;
		public ParserRule getRule() { return rule; }

		//TrueLiteral | FalseLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//TrueLiteral
		public RuleCall getTrueLiteralParserRuleCall_0() { return cTrueLiteralParserRuleCall_0; }

		//FalseLiteral
		public RuleCall getFalseLiteralParserRuleCall_1() { return cFalseLiteralParserRuleCall_1; }
	}

	public class FalseLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FalseLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A FalseLiteral is the text "false".
		//FalseLiteral:
		//	{FalseLiteral} "false";
		public ParserRule getRule() { return rule; }

		//{FalseLiteral} "false"
		public Group getGroup() { return cGroup; }

		//{FalseLiteral}
		public Action getFalseLiteralAction_0() { return cFalseLiteralAction_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class TrueLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrueLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A TrueLiteral is the text "true".
		//TrueLiteral:
		//	{TrueLiteral} "true";
		public ParserRule getRule() { return rule; }

		//{TrueLiteral} "true"
		public Group getGroup() { return cGroup; }

		//{TrueLiteral}
		public Action getTrueLiteralAction_0() { return cTrueLiteralAction_0; }

		//"true"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}
	
	
	private ModelElements pModel;
	private BlockElements pBlock;
	private StatementElements pStatement;
	private TerminalRule tMyEof;
	private ReturnStatementElements pReturnStatement;
	private WhileStatementElements pWhileStatement;
	private IfStatementElements pIfStatement;
	private FunctionDeclarationElements pFunctionDeclaration;
	private ParameterElements pParameter;
	private TypeElements pType;
	private PrimitiveTypeElements pPrimitiveType;
	private IntTypeElements pIntType;
	private BoolTypeElements pBoolType;
	private ArrayTypeElements pArrayType;
	private FunctionCallElements pFunctionCall;
	private AnnotationElements pAnnotation;
	private VariableDeclarationElements pVariableDeclaration;
	private AssignmentElements pAssignment;
	private ExprElements pExpr;
	private ComparisonElements pComparison;
	private ComparisonTypeElements pComparisonType;
	private LessComparisonTypeElements pLessComparisonType;
	private LessOrEqualComparisonTypeElements pLessOrEqualComparisonType;
	private EqualComparisonTypeElements pEqualComparisonType;
	private GreaterOrEqualComparisonTypeElements pGreaterOrEqualComparisonType;
	private GreaterComparisonTypeElements pGreaterComparisonType;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private PostfixOperatorsElements pPostfixOperators;
	private AtomicElements pAtomic;
	private BooleanLiteralElements pBooleanLiteral;
	private FalseLiteralElements pFalseLiteral;
	private TrueLiteralElements pTrueLiteral;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// A program consists of a sequence of statements and/or function declarations.
	//Model:
	//	(statements+=Statement | functions+=FunctionDeclaration)*;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//// Override the whitespace rules since we do not allow newlines to count as whitespace.
	//// terminal WS : (' '|'\t'|'\r')+;
	//// A block consists of multiple statement enclosed in curly brackets.
	//Block:
	//	{Block} "{" statements+=Statement* "}";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// A statement is everything that can be executed in the program.
	//Statement:
	//	VariableDeclaration // ('\n' | MyEof) 
	//	| Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//terminal MyEof:
	//	EOF;
	public TerminalRule getMyEofRule() {
		return (tMyEof != null) ? tMyEof : (tMyEof = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MyEof"));
	} 

	/// *NoOp:
	//	{NoOp}
	//;* / // A return statement returns a value from a function.
	//ReturnStatement:
	//	"return" returnExpr=Expr;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//// A while statement specifies a while loop.
	//WhileStatement:
	//	{WhileStatement} "while";
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	//// An if statement specifies a conditional expression.
	//IfStatement:
	//	{IfStatement} "if";
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//// A function declaration declares a function name, parameters, return type, and function body.
	//FunctionDeclaration:
	//	"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//Parameter returns Symbol:
	//	{Parameter} type=Type name=ID;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//// A type can either be a primitive type or an array of a primitive type
	//Type:
	//	PrimitiveType | ArrayType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// A primitive type represents a variable type that can hold one value.
	//PrimitiveType:
	//	IntType | BoolType;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return (pPrimitiveType != null) ? pPrimitiveType : (pPrimitiveType = new PrimitiveTypeElements());
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}

	//// An integer type represents an arbitrarily large integer.
	//IntType:
	//	{IntType} "int";
	public IntTypeElements getIntTypeAccess() {
		return (pIntType != null) ? pIntType : (pIntType = new IntTypeElements());
	}
	
	public ParserRule getIntTypeRule() {
		return getIntTypeAccess().getRule();
	}

	//// A bool type represents a Boolean value.
	//BoolType:
	//	{BoolType} "bool";
	public BoolTypeElements getBoolTypeAccess() {
		return (pBoolType != null) ? pBoolType : (pBoolType = new BoolTypeElements());
	}
	
	public ParserRule getBoolTypeRule() {
		return getBoolTypeAccess().getRule();
	}

	//// An array type represents an array of a primitive type.
	//ArrayType:
	//	{ArrayType} baseType=PrimitiveType "[" "]";
	public ArrayTypeElements getArrayTypeAccess() {
		return (pArrayType != null) ? pArrayType : (pArrayType = new ArrayTypeElements());
	}
	
	public ParserRule getArrayTypeRule() {
		return getArrayTypeAccess().getRule();
	}

	//// A function call simply calls a function without returning a value. 
	//FunctionCall:
	//	{FunctionCall} "functionCallStatement";
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//// An annotation is used to specify assertions and assumptions.
	//Annotation:
	//	{Annotation} "TODO5";
	public AnnotationElements getAnnotationAccess() {
		return (pAnnotation != null) ? pAnnotation : (pAnnotation = new AnnotationElements());
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// A variable declaration declares a new variable and optionally assigns it a value.
	//VariableDeclaration:
	//	type=Type name=ID (":=" initialValue=Expr);
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return (pVariableDeclaration != null) ? pVariableDeclaration : (pVariableDeclaration = new VariableDeclarationElements());
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	//// An assignment assigns a value to a variable.
	//Assignment:
	//	variable=ID ":=" value=Expr;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//Expr:
	//	Comparison;
	public ExprElements getExprAccess() {
		return (pExpr != null) ? pExpr : (pExpr = new ExprElements());
	}
	
	public ParserRule getExprRule() {
		return getExprAccess().getRule();
	}

	//Comparison returns Expression:
	//	Addition ({Equals.left=current} type=ComparisonType right=Addition)?;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//ComparisonType:
	//	LessComparisonType | LessOrEqualComparisonType | EqualComparisonType | GreaterOrEqualComparisonType |
	//	GreaterComparisonType;
	public ComparisonTypeElements getComparisonTypeAccess() {
		return (pComparisonType != null) ? pComparisonType : (pComparisonType = new ComparisonTypeElements());
	}
	
	public ParserRule getComparisonTypeRule() {
		return getComparisonTypeAccess().getRule();
	}

	//LessComparisonType:
	//	{LessComparisonType} "<";
	public LessComparisonTypeElements getLessComparisonTypeAccess() {
		return (pLessComparisonType != null) ? pLessComparisonType : (pLessComparisonType = new LessComparisonTypeElements());
	}
	
	public ParserRule getLessComparisonTypeRule() {
		return getLessComparisonTypeAccess().getRule();
	}

	//LessOrEqualComparisonType:
	//	{LessOrEqualComparisonType} ("<=" | "≤");
	public LessOrEqualComparisonTypeElements getLessOrEqualComparisonTypeAccess() {
		return (pLessOrEqualComparisonType != null) ? pLessOrEqualComparisonType : (pLessOrEqualComparisonType = new LessOrEqualComparisonTypeElements());
	}
	
	public ParserRule getLessOrEqualComparisonTypeRule() {
		return getLessOrEqualComparisonTypeAccess().getRule();
	}

	//EqualComparisonType:
	//	{EqualComparisonType} "=";
	public EqualComparisonTypeElements getEqualComparisonTypeAccess() {
		return (pEqualComparisonType != null) ? pEqualComparisonType : (pEqualComparisonType = new EqualComparisonTypeElements());
	}
	
	public ParserRule getEqualComparisonTypeRule() {
		return getEqualComparisonTypeAccess().getRule();
	}

	//GreaterOrEqualComparisonType:
	//	{GreaterOrEqualComparisonType} (">=" | "≥");
	public GreaterOrEqualComparisonTypeElements getGreaterOrEqualComparisonTypeAccess() {
		return (pGreaterOrEqualComparisonType != null) ? pGreaterOrEqualComparisonType : (pGreaterOrEqualComparisonType = new GreaterOrEqualComparisonTypeElements());
	}
	
	public ParserRule getGreaterOrEqualComparisonTypeRule() {
		return getGreaterOrEqualComparisonTypeAccess().getRule();
	}

	//GreaterComparisonType:
	//	{GreaterComparisonType} ">";
	public GreaterComparisonTypeElements getGreaterComparisonTypeAccess() {
		return (pGreaterComparisonType != null) ? pGreaterComparisonType : (pGreaterComparisonType = new GreaterComparisonTypeElements());
	}
	
	public ParserRule getGreaterComparisonTypeRule() {
		return getGreaterComparisonTypeAccess().getRule();
	}

	//Addition returns Expression:
	//	Multiplication ({Plus.left=current} "+" right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns Expression:
	//	PostfixOperators ({Multi.left=current} "*" right=PostfixOperators)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//PostfixOperators returns Expression:
	//	Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?;
	public PostfixOperatorsElements getPostfixOperatorsAccess() {
		return (pPostfixOperators != null) ? pPostfixOperators : (pPostfixOperators = new PostfixOperatorsElements());
	}
	
	public ParserRule getPostfixOperatorsRule() {
		return getPostfixOperatorsAccess().getRule();
	}

	//// An atomic value in an expression is either
	////  - a function call or
	////  - a number or
	////  - a Boolean literal.
	//Atomic returns Expression:
	//	{SymbolRef} symbol=[Symbol] ("(" actuals+=Expr? ("," actuals+=Expr)* ")")? / * function call * / / * number * / |
	//	{NumberLiteral} value=INT | / * Boolean literal * / BooleanLiteral;
	public AtomicElements getAtomicAccess() {
		return (pAtomic != null) ? pAtomic : (pAtomic = new AtomicElements());
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	//// A Boolean literal is either "true" or "false"
	//BooleanLiteral:
	//	TrueLiteral | FalseLiteral;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//// A FalseLiteral is the text "false".
	//FalseLiteral:
	//	{FalseLiteral} "false";
	public FalseLiteralElements getFalseLiteralAccess() {
		return (pFalseLiteral != null) ? pFalseLiteral : (pFalseLiteral = new FalseLiteralElements());
	}
	
	public ParserRule getFalseLiteralRule() {
		return getFalseLiteralAccess().getRule();
	}

	//// A TrueLiteral is the text "true".
	//TrueLiteral:
	//	{TrueLiteral} "true";
	public TrueLiteralElements getTrueLiteralAccess() {
		return (pTrueLiteral != null) ? pTrueLiteral : (pTrueLiteral = new TrueLiteralElements());
	}
	
	public ParserRule getTrueLiteralRule() {
		return getTrueLiteralAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
