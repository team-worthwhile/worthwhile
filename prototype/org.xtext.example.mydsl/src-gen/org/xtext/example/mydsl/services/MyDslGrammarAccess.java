/*
* generated by Xtext
*/

package org.xtext.example.mydsl.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class MyDslGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cStatementsAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_0_0_0 = (RuleCall)cStatementsAssignment_0_0.eContents().get(0);
		private final Assignment cFunctionsAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final RuleCall cFunctionsFunctionDeclarationParserRuleCall_0_1_0 = (RuleCall)cFunctionsAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cNLTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cStatementsAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_1_1_0_0 = (RuleCall)cStatementsAssignment_1_1_0.eContents().get(0);
		private final Assignment cFunctionsAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final RuleCall cFunctionsFunctionDeclarationParserRuleCall_1_1_1_0 = (RuleCall)cFunctionsAssignment_1_1_1.eContents().get(0);
		
		//// A program consists of a sequence of statements and/or function declarations.
		//// FIXME: newline at end of file not possible ATM
		//Model:
		//	(statements+=Statement | functions+=FunctionDeclaration)? // The first statement does not need a newline before …
		//	(NL (statements+=Statement | functions+=FunctionDeclaration))* // … but all the other statements do.
		//;
		public ParserRule getRule() { return rule; }

		//(statements+=Statement | functions+=FunctionDeclaration)? // The first statement does not need a newline before …
		//(NL (statements+=Statement | functions+=FunctionDeclaration))* // … but all the other statements do.
		public Group getGroup() { return cGroup; }

		//(statements+=Statement | functions+=FunctionDeclaration)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//statements+=Statement
		public Assignment getStatementsAssignment_0_0() { return cStatementsAssignment_0_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0_0_0() { return cStatementsStatementParserRuleCall_0_0_0; }

		//functions+=FunctionDeclaration
		public Assignment getFunctionsAssignment_0_1() { return cFunctionsAssignment_0_1; }

		//FunctionDeclaration
		public RuleCall getFunctionsFunctionDeclarationParserRuleCall_0_1_0() { return cFunctionsFunctionDeclarationParserRuleCall_0_1_0; }

		//(NL (statements+=Statement | functions+=FunctionDeclaration))*
		public Group getGroup_1() { return cGroup_1; }

		//NL
		public RuleCall getNLTerminalRuleCall_1_0() { return cNLTerminalRuleCall_1_0; }

		//statements+=Statement | functions+=FunctionDeclaration
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//statements+=Statement
		public Assignment getStatementsAssignment_1_1_0() { return cStatementsAssignment_1_1_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_1_0_0() { return cStatementsStatementParserRuleCall_1_1_0_0; }

		//functions+=FunctionDeclaration
		public Assignment getFunctionsAssignment_1_1_1() { return cFunctionsAssignment_1_1_1; }

		//FunctionDeclaration
		public RuleCall getFunctionsFunctionDeclarationParserRuleCall_1_1_1_0() { return cFunctionsFunctionDeclarationParserRuleCall_1_1_1_0; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cNLTerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cStatementsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_3_1_0 = (RuleCall)cStatementsAssignment_3_1.eContents().get(0);
		private final RuleCall cNLTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// … as well as single line comments. TODO: does not work ATM
		/// * terminal SL_COMMENT :
		//	NL? '//' !('\n'|'\r')* ('\r'? '\n')?
		//;* / // A block consists of one or multiple statements enclosed in curly brackets.
		//Block:
		//	{Block} "{" statements+=Statement? (NL statements+=Statement)* NL? "}";
		public ParserRule getRule() { return rule; }

		//{Block} "{" statements+=Statement? (NL statements+=Statement)* NL? "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statements+=Statement?
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }

		//(NL statements+=Statement)*
		public Group getGroup_3() { return cGroup_3; }

		//NL
		public RuleCall getNLTerminalRuleCall_3_0() { return cNLTerminalRuleCall_3_0; }

		//statements+=Statement
		public Assignment getStatementsAssignment_3_1() { return cStatementsAssignment_3_1; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_3_1_0() { return cStatementsStatementParserRuleCall_3_1_0; }

		//NL?
		public RuleCall getNLTerminalRuleCall_4() { return cNLTerminalRuleCall_4; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssignmentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cAnnotationParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIfStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cWhileStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cReturnStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//// A statement is everything that can be executed in the program.
		//Statement:
		//	VariableDeclaration | Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement;
		public ParserRule getRule() { return rule; }

		//VariableDeclaration | Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableDeclaration
		public RuleCall getVariableDeclarationParserRuleCall_0() { return cVariableDeclarationParserRuleCall_0; }

		//Assignment
		public RuleCall getAssignmentParserRuleCall_1() { return cAssignmentParserRuleCall_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }

		//Annotation
		public RuleCall getAnnotationParserRuleCall_3() { return cAnnotationParserRuleCall_3; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_4() { return cFunctionCallParserRuleCall_4; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_5() { return cIfStatementParserRuleCall_5; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_6() { return cWhileStatementParserRuleCall_6; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_7() { return cReturnStatementParserRuleCall_7; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnExprExprParserRuleCall_1_0 = (RuleCall)cReturnExprAssignment_1.eContents().get(0);
		
		//// A return statement returns a value from a function.
		//ReturnStatement:
		//	"return" returnExpr=Expr;
		public ParserRule getRule() { return rule; }

		//"return" returnExpr=Expr
		public Group getGroup() { return cGroup; }

		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }

		//returnExpr=Expr
		public Assignment getReturnExprAssignment_1() { return cReturnExprAssignment_1; }

		//Expr
		public RuleCall getReturnExprExprParserRuleCall_1_0() { return cReturnExprExprParserRuleCall_1_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExprParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyBlockParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		
		//// A while statement specifies a while loop.
		//WhileStatement:
		//	"while" condition=Expr body=Block;
		public ParserRule getRule() { return rule; }

		//"while" condition=Expr body=Block
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//condition=Expr
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expr
		public RuleCall getConditionExprParserRuleCall_1_0() { return cConditionExprParserRuleCall_1_0; }

		//body=Block
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_2_0() { return cBodyBlockParserRuleCall_2_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExprParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Assignment cThenAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cThenBlockParserRuleCall_2_0 = (RuleCall)cThenAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cElseKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cElseAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cElseBlockParserRuleCall_3_1_0 = (RuleCall)cElseAssignment_3_1.eContents().get(0);
		
		//// An if statement specifies a conditional expression.
		//IfStatement:
		//	"if" condition=Expr then=Block ("else" else=Block)?;
		public ParserRule getRule() { return rule; }

		//"if" condition=Expr then=Block ("else" else=Block)?
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//condition=Expr
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }

		//Expr
		public RuleCall getConditionExprParserRuleCall_1_0() { return cConditionExprParserRuleCall_1_0; }

		//then=Block
		public Assignment getThenAssignment_2() { return cThenAssignment_2; }

		//Block
		public RuleCall getThenBlockParserRuleCall_2_0() { return cThenBlockParserRuleCall_2_0; }

		//("else" else=Block)?
		public Group getGroup_3() { return cGroup_3; }

		//"else"
		public Keyword getElseKeyword_3_0() { return cElseKeyword_3_0; }

		//else=Block
		public Assignment getElseAssignment_3_1() { return cElseAssignment_3_1; }

		//Block
		public RuleCall getElseBlockParserRuleCall_3_1_0() { return cElseBlockParserRuleCall_3_1_0; }
	}

	public class FunctionDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cReturnTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cReturnTypeTypeParserRuleCall_1_0 = (RuleCall)cReturnTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cParamsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cParamsParameterParserRuleCall_4_0_0 = (RuleCall)cParamsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cParamsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cParamsParameterParserRuleCall_4_1_1_0 = (RuleCall)cParamsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cBodyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cBodyBlockParserRuleCall_6_0 = (RuleCall)cBodyAssignment_6.eContents().get(0);
		
		//// A function declaration declares a function name, parameters, return type, and function body.
		//FunctionDeclaration returns Function:
		//	"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block;
		public ParserRule getRule() { return rule; }

		//"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//returnType=Type
		public Assignment getReturnTypeAssignment_1() { return cReturnTypeAssignment_1; }

		//Type
		public RuleCall getReturnTypeTypeParserRuleCall_1_0() { return cReturnTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(params+=Parameter ("," params+=Parameter)*)?
		public Group getGroup_4() { return cGroup_4; }

		//params+=Parameter
		public Assignment getParamsAssignment_4_0() { return cParamsAssignment_4_0; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_4_0_0() { return cParamsParameterParserRuleCall_4_0_0; }

		//("," params+=Parameter)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//params+=Parameter
		public Assignment getParamsAssignment_4_1_1() { return cParamsAssignment_4_1_1; }

		//Parameter
		public RuleCall getParamsParameterParserRuleCall_4_1_1_0() { return cParamsParameterParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//body=Block
		public Assignment getBodyAssignment_6() { return cBodyAssignment_6; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_6_0() { return cBodyBlockParserRuleCall_6_0; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		
		//// A parameter definition describes a single parameter (type and name) accepted by a function.
		//Parameter returns Variable:
		//	{Parameter} type=Type name=ID;
		public ParserRule getRule() { return rule; }

		//{Parameter} type=Type name=ID
		public Group getGroup() { return cGroup; }

		//{Parameter}
		public Action getParameterAction_0() { return cParameterAction_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_1_0() { return cTypeTypeParserRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitiveTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A type can either be a primitive type or an array of a primitive type
		//Type:
		//	PrimitiveType | ArrayType;
		public ParserRule getRule() { return rule; }

		//PrimitiveType | ArrayType
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimitiveType
		public RuleCall getPrimitiveTypeParserRuleCall_0() { return cPrimitiveTypeParserRuleCall_0; }

		//ArrayType
		public RuleCall getArrayTypeParserRuleCall_1() { return cArrayTypeParserRuleCall_1; }
	}

	public class PrimitiveTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimitiveType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A primitive type represents a variable type that can hold one value.
		//PrimitiveType:
		//	IntType | BoolType;
		public ParserRule getRule() { return rule; }

		//IntType | BoolType
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntType
		public RuleCall getIntTypeParserRuleCall_0() { return cIntTypeParserRuleCall_0; }

		//BoolType
		public RuleCall getBoolTypeParserRuleCall_1() { return cBoolTypeParserRuleCall_1; }
	}

	public class IntTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIntTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIntKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// An integer type represents an arbitrarily large integer.
		//IntType:
		//	{IntType} "int";
		public ParserRule getRule() { return rule; }

		//{IntType} "int"
		public Group getGroup() { return cGroup; }

		//{IntType}
		public Action getIntTypeAction_0() { return cIntTypeAction_0; }

		//"int"
		public Keyword getIntKeyword_1() { return cIntKeyword_1; }
	}

	public class BoolTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBoolTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBoolKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A bool type represents a Boolean value.
		//BoolType:
		//	{BoolType} "bool";
		public ParserRule getRule() { return rule; }

		//{BoolType} "bool"
		public Group getGroup() { return cGroup; }

		//{BoolType}
		public Action getBoolTypeAction_0() { return cBoolTypeAction_0; }

		//"bool"
		public Keyword getBoolKeyword_1() { return cBoolKeyword_1; }
	}

	public class ArrayTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArrayType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cArrayTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cBaseTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBaseTypePrimitiveTypeParserRuleCall_1_0 = (RuleCall)cBaseTypeAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// An array type represents an array of a primitive type.
		//ArrayType:
		//	{ArrayType} baseType=PrimitiveType "[" "]";
		public ParserRule getRule() { return rule; }

		//{ArrayType} baseType=PrimitiveType "[" "]"
		public Group getGroup() { return cGroup; }

		//{ArrayType}
		public Action getArrayTypeAction_0() { return cArrayTypeAction_0; }

		//baseType=PrimitiveType
		public Assignment getBaseTypeAssignment_1() { return cBaseTypeAssignment_1; }

		//PrimitiveType
		public RuleCall getBaseTypePrimitiveTypeParserRuleCall_1_0() { return cBaseTypePrimitiveTypeParserRuleCall_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSymbolFunctionCrossReference_1_0 = (CrossReference)cSymbolAssignment_1.eContents().get(0);
		private final RuleCall cSymbolFunctionIDTerminalRuleCall_1_0_1 = (RuleCall)cSymbolFunctionCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActualsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActualsExprParserRuleCall_3_0 = (RuleCall)cActualsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cActualsAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cActualsExprParserRuleCall_4_1_0 = (RuleCall)cActualsAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// A function call simply calls a function without returning a value. 
		//FunctionCall:
		//	{FunctionRef} symbol=[Function] "(" actuals+=Expr? ("," actuals+=Expr)* ")";
		public ParserRule getRule() { return rule; }

		//{FunctionRef} symbol=[Function] "(" actuals+=Expr? ("," actuals+=Expr)* ")"
		public Group getGroup() { return cGroup; }

		//{FunctionRef}
		public Action getFunctionRefAction_0() { return cFunctionRefAction_0; }

		//symbol=[Function]
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }

		//[Function]
		public CrossReference getSymbolFunctionCrossReference_1_0() { return cSymbolFunctionCrossReference_1_0; }

		//ID
		public RuleCall getSymbolFunctionIDTerminalRuleCall_1_0_1() { return cSymbolFunctionIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//actuals+=Expr?
		public Assignment getActualsAssignment_3() { return cActualsAssignment_3; }

		//Expr
		public RuleCall getActualsExprParserRuleCall_3_0() { return cActualsExprParserRuleCall_3_0; }

		//("," actuals+=Expr)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//actuals+=Expr
		public Assignment getActualsAssignment_4_1() { return cActualsAssignment_4_1; }

		//Expr
		public RuleCall getActualsExprParserRuleCall_4_1_0() { return cActualsExprParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class AnnotationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Annotation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAnnotationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTODOKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// An annotation is used to specify assertions and assumptions.
		//Annotation:
		//	{Annotation} "TODO";
		public ParserRule getRule() { return rule; }

		//{Annotation} "TODO"
		public Group getGroup() { return cGroup; }

		//{Annotation}
		public Action getAnnotationAction_0() { return cAnnotationAction_0; }

		//"TODO"
		public Keyword getTODOKeyword_1() { return cTODOKeyword_1; }
	}

	public class VariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonEqualsSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cInitialValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cInitialValueExprParserRuleCall_2_1_0 = (RuleCall)cInitialValueAssignment_2_1.eContents().get(0);
		
		//// A variable declaration declares a new variable and optionally assigns it a value.
		//VariableDeclaration returns Variable:
		//	type=Type name=ID (":=" initialValue=Expr);
		public ParserRule getRule() { return rule; }

		//type=Type name=ID (":=" initialValue=Expr)
		public Group getGroup() { return cGroup; }

		//type=Type
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_0_0() { return cTypeTypeParserRuleCall_0_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":=" initialValue=Expr
		public Group getGroup_2() { return cGroup_2; }

		//":="
		public Keyword getColonEqualsSignKeyword_2_0() { return cColonEqualsSignKeyword_2_0; }

		//initialValue=Expr
		public Assignment getInitialValueAssignment_2_1() { return cInitialValueAssignment_2_1; }

		//Expr
		public RuleCall getInitialValueExprParserRuleCall_2_1_0() { return cInitialValueExprParserRuleCall_2_1_0; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cVariableVariableCrossReference_0_0 = (CrossReference)cVariableAssignment_0.eContents().get(0);
		private final RuleCall cVariableVariableIDTerminalRuleCall_0_0_1 = (RuleCall)cVariableVariableCrossReference_0_0.eContents().get(1);
		private final Keyword cColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExprParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// An assignment assigns a value to a variable.
		//Assignment:
		//	variable=[Variable] ":=" value=Expr;
		public ParserRule getRule() { return rule; }

		//variable=[Variable] ":=" value=Expr
		public Group getGroup() { return cGroup; }

		//variable=[Variable]
		public Assignment getVariableAssignment_0() { return cVariableAssignment_0; }

		//[Variable]
		public CrossReference getVariableVariableCrossReference_0_0() { return cVariableVariableCrossReference_0_0; }

		//ID
		public RuleCall getVariableVariableIDTerminalRuleCall_0_0_1() { return cVariableVariableIDTerminalRuleCall_0_0_1; }

		//":="
		public Keyword getColonEqualsSignKeyword_1() { return cColonEqualsSignKeyword_1; }

		//value=Expr
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expr
		public RuleCall getValueExprParserRuleCall_2_0() { return cValueExprParserRuleCall_2_0; }
	}

	public class ExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expr");
		private final RuleCall cEqualsComparisonParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expr:
		//	EqualsComparison;
		public ParserRule getRule() { return rule; }

		//EqualsComparison
		public RuleCall getEqualsComparisonParserRuleCall() { return cEqualsComparisonParserRuleCall; }
	}

	public class EqualsComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualsComparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualsLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//EqualsComparison returns Expression:
		//	Comparison ({Equals.left=current} "=" right=Comparison)?;
		public ParserRule getRule() { return rule; }

		//Comparison ({Equals.left=current} "=" right=Comparison)?
		public Group getGroup() { return cGroup; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }

		//({Equals.left=current} "=" right=Comparison)?
		public Group getGroup_1() { return cGroup_1; }

		//{Equals.left=current}
		public Action getEqualsLeftAction_1_0() { return cEqualsLeftAction_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_1() { return cEqualsSignKeyword_1_1; }

		//right=Comparison
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_2_0() { return cRightComparisonParserRuleCall_1_2_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCompareLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeComparisonTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdditionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Comparison returns Expression:
		//	Addition ({Compare.left=current} type=ComparisonType right=Addition)?;
		public ParserRule getRule() { return rule; }

		//Addition ({Compare.left=current} type=ComparisonType right=Addition)?
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//({Compare.left=current} type=ComparisonType right=Addition)?
		public Group getGroup_1() { return cGroup_1; }

		//{Compare.left=current}
		public Action getCompareLeftAction_1_0() { return cCompareLeftAction_1_0; }

		//type=ComparisonType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//ComparisonType
		public RuleCall getTypeComparisonTypeParserRuleCall_1_1_0() { return cTypeComparisonTypeParserRuleCall_1_1_0; }

		//right=Addition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_2_0() { return cRightAdditionParserRuleCall_1_2_0; }
	}

	public class ComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLessComparisonTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLessOrEqualComparisonTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cGreaterOrEqualComparisonTypeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGreaterComparisonTypeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//ComparisonType:
		//	LessComparisonType | LessOrEqualComparisonType | GreaterOrEqualComparisonType | GreaterComparisonType;
		public ParserRule getRule() { return rule; }

		//LessComparisonType | LessOrEqualComparisonType | GreaterOrEqualComparisonType | GreaterComparisonType
		public Alternatives getAlternatives() { return cAlternatives; }

		//LessComparisonType
		public RuleCall getLessComparisonTypeParserRuleCall_0() { return cLessComparisonTypeParserRuleCall_0; }

		//LessOrEqualComparisonType
		public RuleCall getLessOrEqualComparisonTypeParserRuleCall_1() { return cLessOrEqualComparisonTypeParserRuleCall_1; }

		//GreaterOrEqualComparisonType
		public RuleCall getGreaterOrEqualComparisonTypeParserRuleCall_2() { return cGreaterOrEqualComparisonTypeParserRuleCall_2; }

		//GreaterComparisonType
		public RuleCall getGreaterComparisonTypeParserRuleCall_3() { return cGreaterComparisonTypeParserRuleCall_3; }
	}

	public class LessComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LessComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLessComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//LessComparisonType:
		//	{LessComparisonType} "<";
		public ParserRule getRule() { return rule; }

		//{LessComparisonType} "<"
		public Group getGroup() { return cGroup; }

		//{LessComparisonType}
		public Action getLessComparisonTypeAction_0() { return cLessComparisonTypeAction_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }
	}

	public class LessOrEqualComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LessOrEqualComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLessOrEqualComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cLessThanOrEqualToKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//LessOrEqualComparisonType:
		//	{LessOrEqualComparisonType} ("<=" | "≤");
		public ParserRule getRule() { return rule; }

		//{LessOrEqualComparisonType} ("<=" | "≤")
		public Group getGroup() { return cGroup; }

		//{LessOrEqualComparisonType}
		public Action getLessOrEqualComparisonTypeAction_0() { return cLessOrEqualComparisonTypeAction_0; }

		//"<=" | "≤"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0() { return cLessThanSignEqualsSignKeyword_1_0; }

		//"≤"
		public Keyword getLessThanOrEqualToKeyword_1_1() { return cLessThanOrEqualToKeyword_1_1; }
	}

	public class GreaterOrEqualComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GreaterOrEqualComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGreaterOrEqualComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cGreaterThanOrEqualToKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//GreaterOrEqualComparisonType:
		//	{GreaterOrEqualComparisonType} (">=" | "≥");
		public ParserRule getRule() { return rule; }

		//{GreaterOrEqualComparisonType} (">=" | "≥")
		public Group getGroup() { return cGroup; }

		//{GreaterOrEqualComparisonType}
		public Action getGreaterOrEqualComparisonTypeAction_0() { return cGreaterOrEqualComparisonTypeAction_0; }

		//">=" | "≥"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0() { return cGreaterThanSignEqualsSignKeyword_1_0; }

		//"≥"
		public Keyword getGreaterThanOrEqualToKeyword_1_1() { return cGreaterThanOrEqualToKeyword_1_1; }
	}

	public class GreaterComparisonTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GreaterComparisonType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cGreaterComparisonTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//GreaterComparisonType:
		//	{GreaterComparisonType} ">";
		public ParserRule getRule() { return rule; }

		//{GreaterComparisonType} ">"
		public Group getGroup() { return cGroup; }

		//{GreaterComparisonType}
		public Action getGreaterComparisonTypeAction_0() { return cGreaterComparisonTypeAction_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1() { return cGreaterThanSignKeyword_1; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeAdditionTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Addition returns Expression:
		//	Multiplication ({Plus.left=current} type=AdditionType right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication ({Plus.left=current} type=AdditionType right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Plus.left=current} type=AdditionType right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0() { return cPlusLeftAction_1_0; }

		//type=AdditionType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//AdditionType
		public RuleCall getTypeAdditionTypeParserRuleCall_1_1_0() { return cTypeAdditionTypeParserRuleCall_1_1_0; }

		//right=Multiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_2_0() { return cRightMultiplicationParserRuleCall_1_2_0; }
	}

	public class AdditionTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAdditionOpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubtractionOpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AdditionType:
		//	AdditionOp | SubtractionOp;
		public ParserRule getRule() { return rule; }

		//AdditionOp | SubtractionOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//AdditionOp
		public RuleCall getAdditionOpParserRuleCall_0() { return cAdditionOpParserRuleCall_0; }

		//SubtractionOp
		public RuleCall getSubtractionOpParserRuleCall_1() { return cSubtractionOpParserRuleCall_1; }
	}

	public class AdditionOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AdditionOp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAdditionOpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPlusSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//AdditionOp:
		//	{AdditionOp} "+";
		public ParserRule getRule() { return rule; }

		//{AdditionOp} "+"
		public Group getGroup() { return cGroup; }

		//{AdditionOp}
		public Action getAdditionOpAction_0() { return cAdditionOpAction_0; }

		//"+"
		public Keyword getPlusSignKeyword_1() { return cPlusSignKeyword_1; }
	}

	public class SubtractionOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SubtractionOp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSubtractionOpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//SubtractionOp:
		//	{SubtractionOp} "-";
		public ParserRule getRule() { return rule; }

		//{SubtractionOp} "-"
		public Group getGroup() { return cGroup; }

		//{SubtractionOp}
		public Action getSubtractionOpAction_0() { return cSubtractionOpAction_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPostfixOperatorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cTypeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTypeMultiplicationTypeParserRuleCall_1_1_0 = (RuleCall)cTypeAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPostfixOperatorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Multiplication returns Expression:
		//	PostfixOperator ({Multi.left=current} type=MultiplicationType right=PostfixOperator)*;
		public ParserRule getRule() { return rule; }

		//PostfixOperator ({Multi.left=current} type=MultiplicationType right=PostfixOperator)*
		public Group getGroup() { return cGroup; }

		//PostfixOperator
		public RuleCall getPostfixOperatorParserRuleCall_0() { return cPostfixOperatorParserRuleCall_0; }

		//({Multi.left=current} type=MultiplicationType right=PostfixOperator)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0() { return cMultiLeftAction_1_0; }

		//type=MultiplicationType
		public Assignment getTypeAssignment_1_1() { return cTypeAssignment_1_1; }

		//MultiplicationType
		public RuleCall getTypeMultiplicationTypeParserRuleCall_1_1_0() { return cTypeMultiplicationTypeParserRuleCall_1_1_0; }

		//right=PostfixOperator
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PostfixOperator
		public RuleCall getRightPostfixOperatorParserRuleCall_1_2_0() { return cRightPostfixOperatorParserRuleCall_1_2_0; }
	}

	public class MultiplicationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMultiplicationOpParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDivisionOpParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cModuloOpParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//MultiplicationType:
		//	MultiplicationOp | DivisionOp | ModuloOp;
		public ParserRule getRule() { return rule; }

		//MultiplicationOp | DivisionOp | ModuloOp
		public Alternatives getAlternatives() { return cAlternatives; }

		//MultiplicationOp
		public RuleCall getMultiplicationOpParserRuleCall_0() { return cMultiplicationOpParserRuleCall_0; }

		//DivisionOp
		public RuleCall getDivisionOpParserRuleCall_1() { return cDivisionOpParserRuleCall_1; }

		//ModuloOp
		public RuleCall getModuloOpParserRuleCall_2() { return cModuloOpParserRuleCall_2; }
	}

	public class MultiplicationOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultiplicationOp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMultiplicationOpAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cMiddleDotKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//MultiplicationOp:
		//	{MultiplicationOp} ("*" | "·");
		public ParserRule getRule() { return rule; }

		//{MultiplicationOp} ("*" | "·")
		public Group getGroup() { return cGroup; }

		//{MultiplicationOp}
		public Action getMultiplicationOpAction_0() { return cMultiplicationOpAction_0; }

		//"*" | "·"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_0() { return cAsteriskKeyword_1_0; }

		//"·"
		public Keyword getMiddleDotKeyword_1_1() { return cMiddleDotKeyword_1_1; }
	}

	public class DivisionOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DivisionOp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDivisionOpAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cSolidusKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cDivisionSignKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//DivisionOp:
		//	{DivisionOp} ("/" | "÷");
		public ParserRule getRule() { return rule; }

		//{DivisionOp} ("/" | "÷")
		public Group getGroup() { return cGroup; }

		//{DivisionOp}
		public Action getDivisionOpAction_0() { return cDivisionOpAction_0; }

		//"/" | "÷"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"/"
		public Keyword getSolidusKeyword_1_0() { return cSolidusKeyword_1_0; }

		//"÷"
		public Keyword getDivisionSignKeyword_1_1() { return cDivisionSignKeyword_1_1; }
	}

	public class ModuloOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModuloOp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModuloOpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPercentSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ModuloOp:
		//	{ModuloOp} "%";
		public ParserRule getRule() { return rule; }

		//{ModuloOp} "%"
		public Group getGroup() { return cGroup; }

		//{ModuloOp}
		public Action getModuloOpAction_0() { return cModuloOpAction_0; }

		//"%"
		public Keyword getPercentSignKeyword_1() { return cPercentSignKeyword_1; }
	}

	public class PostfixOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PostfixOperator");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cArrayAccessExprAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIndexAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIndexExprParserRuleCall_1_2_0 = (RuleCall)cIndexAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//// TODO: unary expressions
		/// *UnaryMinusOperator returns Expression:
		//	 ('-' {UnaryMinus.expr=current})? PostfixOperator
		//;* / PostfixOperator returns Expression:
		//	Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?;
		public ParserRule getRule() { return rule; }

		//Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?
		public Group getGroup() { return cGroup; }

		//Atomic
		public RuleCall getAtomicParserRuleCall_0() { return cAtomicParserRuleCall_0; }

		//({ArrayAccess.expr=current} "[" index=Expr "]")?
		public Group getGroup_1() { return cGroup_1; }

		//{ArrayAccess.expr=current}
		public Action getArrayAccessExprAction_1_0() { return cArrayAccessExprAction_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }

		//index=Expr
		public Assignment getIndexAssignment_1_2() { return cIndexAssignment_1_2; }

		//Expr
		public RuleCall getIndexExprParserRuleCall_1_2_0() { return cIndexExprParserRuleCall_1_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
	}

	public class AtomicElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atomic");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFunctionCallParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumberLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final RuleCall cBooleanLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cVariableRefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cExprAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cExprExprParserRuleCall_4_1_0 = (RuleCall)cExprAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//// An atomic value in an expression is either
		////  - a function call or
		////  - a number or
		////  - a Boolean literal or
		////  - a reference to a variable
		////  - a whole new expression in parentheses.
		//Atomic returns Expression:
		//	FunctionCall | {NumberLiteral} value=INT | BooleanLiteral | VariableRef | "(" expr=Expr ")";
		public ParserRule getRule() { return rule; }

		//FunctionCall | {NumberLiteral} value=INT | BooleanLiteral | VariableRef | "(" expr=Expr ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_0() { return cFunctionCallParserRuleCall_0; }

		//{NumberLiteral} value=INT
		public Group getGroup_1() { return cGroup_1; }

		//{NumberLiteral}
		public Action getNumberLiteralAction_1_0() { return cNumberLiteralAction_1_0; }

		//value=INT
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_1_0() { return cValueINTTerminalRuleCall_1_1_0; }

		//BooleanLiteral
		public RuleCall getBooleanLiteralParserRuleCall_2() { return cBooleanLiteralParserRuleCall_2; }

		//VariableRef
		public RuleCall getVariableRefParserRuleCall_3() { return cVariableRefParserRuleCall_3; }

		//"(" expr=Expr ")"
		public Group getGroup_4() { return cGroup_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//expr=Expr
		public Assignment getExprAssignment_4_1() { return cExprAssignment_4_1; }

		//Expr
		public RuleCall getExprExprParserRuleCall_4_1_0() { return cExprExprParserRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}

	public class BooleanLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTrueLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFalseLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// A Boolean literal is either "true" or "false"
		//BooleanLiteral:
		//	TrueLiteral | FalseLiteral;
		public ParserRule getRule() { return rule; }

		//TrueLiteral | FalseLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//TrueLiteral
		public RuleCall getTrueLiteralParserRuleCall_0() { return cTrueLiteralParserRuleCall_0; }

		//FalseLiteral
		public RuleCall getFalseLiteralParserRuleCall_1() { return cFalseLiteralParserRuleCall_1; }
	}

	public class FalseLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FalseLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A FalseLiteral is the text "false".
		//FalseLiteral:
		//	{FalseLiteral} "false";
		public ParserRule getRule() { return rule; }

		//{FalseLiteral} "false"
		public Group getGroup() { return cGroup; }

		//{FalseLiteral}
		public Action getFalseLiteralAction_0() { return cFalseLiteralAction_0; }

		//"false"
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class TrueLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TrueLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// A TrueLiteral is the text "true".
		//TrueLiteral:
		//	{TrueLiteral} "true";
		public ParserRule getRule() { return rule; }

		//{TrueLiteral} "true"
		public Group getGroup() { return cGroup; }

		//{TrueLiteral}
		public Action getTrueLiteralAction_0() { return cTrueLiteralAction_0; }

		//"true"
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}

	public class VariableRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cSymbolAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cSymbolVariableCrossReference_1_0 = (CrossReference)cSymbolAssignment_1.eContents().get(0);
		private final RuleCall cSymbolVariableIDTerminalRuleCall_1_0_1 = (RuleCall)cSymbolVariableCrossReference_1_0.eContents().get(1);
		
		//VariableRef:
		//	{VariableRef} symbol=[Variable];
		public ParserRule getRule() { return rule; }

		//{VariableRef} symbol=[Variable]
		public Group getGroup() { return cGroup; }

		//{VariableRef}
		public Action getVariableRefAction_0() { return cVariableRefAction_0; }

		//symbol=[Variable]
		public Assignment getSymbolAssignment_1() { return cSymbolAssignment_1; }

		//[Variable]
		public CrossReference getSymbolVariableCrossReference_1_0() { return cSymbolVariableCrossReference_1_0; }

		//ID
		public RuleCall getSymbolVariableIDTerminalRuleCall_1_0_1() { return cSymbolVariableIDTerminalRuleCall_1_0_1; }
	}
	
	
	private ModelElements pModel;
	private TerminalRule tWS;
	private TerminalRule tNL;
	private TerminalRule tML_COMMENT;
	private BlockElements pBlock;
	private StatementElements pStatement;
	private ReturnStatementElements pReturnStatement;
	private WhileStatementElements pWhileStatement;
	private IfStatementElements pIfStatement;
	private FunctionDeclarationElements pFunctionDeclaration;
	private ParameterElements pParameter;
	private TypeElements pType;
	private PrimitiveTypeElements pPrimitiveType;
	private IntTypeElements pIntType;
	private BoolTypeElements pBoolType;
	private ArrayTypeElements pArrayType;
	private FunctionCallElements pFunctionCall;
	private AnnotationElements pAnnotation;
	private VariableDeclarationElements pVariableDeclaration;
	private AssignmentElements pAssignment;
	private ExprElements pExpr;
	private EqualsComparisonElements pEqualsComparison;
	private ComparisonElements pComparison;
	private ComparisonTypeElements pComparisonType;
	private LessComparisonTypeElements pLessComparisonType;
	private LessOrEqualComparisonTypeElements pLessOrEqualComparisonType;
	private GreaterOrEqualComparisonTypeElements pGreaterOrEqualComparisonType;
	private GreaterComparisonTypeElements pGreaterComparisonType;
	private AdditionElements pAddition;
	private AdditionTypeElements pAdditionType;
	private AdditionOpElements pAdditionOp;
	private SubtractionOpElements pSubtractionOp;
	private MultiplicationElements pMultiplication;
	private MultiplicationTypeElements pMultiplicationType;
	private MultiplicationOpElements pMultiplicationOp;
	private DivisionOpElements pDivisionOp;
	private ModuloOpElements pModuloOp;
	private PostfixOperatorElements pPostfixOperator;
	private AtomicElements pAtomic;
	private BooleanLiteralElements pBooleanLiteral;
	private FalseLiteralElements pFalseLiteral;
	private TrueLiteralElements pTrueLiteral;
	private VariableRefElements pVariableRef;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public MyDslGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// A program consists of a sequence of statements and/or function declarations.
	//// FIXME: newline at end of file not possible ATM
	//Model:
	//	(statements+=Statement | functions+=FunctionDeclaration)? // The first statement does not need a newline before …
	//	(NL (statements+=Statement | functions+=FunctionDeclaration))* // … but all the other statements do.
	//;
	public ModelElements getModelAccess() {
		return (pModel != null) ? pModel : (pModel = new ModelElements());
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//// Override the whitespace rules: Disallow line breaks as whitespace since we want to use them to separate statements 
	//terminal WS:
	//	(" " | "\t")+;
	public TerminalRule getWSRule() {
		return (tWS != null) ? tWS : (tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS"));
	} 

	//// A newline preceding a statement consists of at least a newline character, optionally followed by some whitespace and moar newlines.
	//// The latter is necessary because of "blank lines" that have some whitespace (e.g. indentation) in them.
	//// TODO: \r
	//terminal NL:
	//	"\n" ("\n" | WS)*;
	public TerminalRule getNLRule() {
		return (tNL != null) ? tNL : (tNL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NL"));
	} 

	//// Multiline comments must also be able to have line breaks before and after …
	//terminal ML_COMMENT:
	//	NL? "/ *"->"* /" NL?;
	public TerminalRule getML_COMMENTRule() {
		return (tML_COMMENT != null) ? tML_COMMENT : (tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ML_COMMENT"));
	} 

	//// … as well as single line comments. TODO: does not work ATM
	/// * terminal SL_COMMENT :
	//	NL? '//' !('\n'|'\r')* ('\r'? '\n')?
	//;* / // A block consists of one or multiple statements enclosed in curly brackets.
	//Block:
	//	{Block} "{" statements+=Statement? (NL statements+=Statement)* NL? "}";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// A statement is everything that can be executed in the program.
	//Statement:
	//	VariableDeclaration | Assignment | Block | Annotation | FunctionCall | IfStatement | WhileStatement | ReturnStatement;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// A return statement returns a value from a function.
	//ReturnStatement:
	//	"return" returnExpr=Expr;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//// A while statement specifies a while loop.
	//WhileStatement:
	//	"while" condition=Expr body=Block;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	//// An if statement specifies a conditional expression.
	//IfStatement:
	//	"if" condition=Expr then=Block ("else" else=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//// A function declaration declares a function name, parameters, return type, and function body.
	//FunctionDeclaration returns Function:
	//	"function" returnType=Type name=ID "(" (params+=Parameter ("," params+=Parameter)*)? ")" body=Block;
	public FunctionDeclarationElements getFunctionDeclarationAccess() {
		return (pFunctionDeclaration != null) ? pFunctionDeclaration : (pFunctionDeclaration = new FunctionDeclarationElements());
	}
	
	public ParserRule getFunctionDeclarationRule() {
		return getFunctionDeclarationAccess().getRule();
	}

	//// A parameter definition describes a single parameter (type and name) accepted by a function.
	//Parameter returns Variable:
	//	{Parameter} type=Type name=ID;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//// A type can either be a primitive type or an array of a primitive type
	//Type:
	//	PrimitiveType | ArrayType;
	public TypeElements getTypeAccess() {
		return (pType != null) ? pType : (pType = new TypeElements());
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//// A primitive type represents a variable type that can hold one value.
	//PrimitiveType:
	//	IntType | BoolType;
	public PrimitiveTypeElements getPrimitiveTypeAccess() {
		return (pPrimitiveType != null) ? pPrimitiveType : (pPrimitiveType = new PrimitiveTypeElements());
	}
	
	public ParserRule getPrimitiveTypeRule() {
		return getPrimitiveTypeAccess().getRule();
	}

	//// An integer type represents an arbitrarily large integer.
	//IntType:
	//	{IntType} "int";
	public IntTypeElements getIntTypeAccess() {
		return (pIntType != null) ? pIntType : (pIntType = new IntTypeElements());
	}
	
	public ParserRule getIntTypeRule() {
		return getIntTypeAccess().getRule();
	}

	//// A bool type represents a Boolean value.
	//BoolType:
	//	{BoolType} "bool";
	public BoolTypeElements getBoolTypeAccess() {
		return (pBoolType != null) ? pBoolType : (pBoolType = new BoolTypeElements());
	}
	
	public ParserRule getBoolTypeRule() {
		return getBoolTypeAccess().getRule();
	}

	//// An array type represents an array of a primitive type.
	//ArrayType:
	//	{ArrayType} baseType=PrimitiveType "[" "]";
	public ArrayTypeElements getArrayTypeAccess() {
		return (pArrayType != null) ? pArrayType : (pArrayType = new ArrayTypeElements());
	}
	
	public ParserRule getArrayTypeRule() {
		return getArrayTypeAccess().getRule();
	}

	//// A function call simply calls a function without returning a value. 
	//FunctionCall:
	//	{FunctionRef} symbol=[Function] "(" actuals+=Expr? ("," actuals+=Expr)* ")";
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//// An annotation is used to specify assertions and assumptions.
	//Annotation:
	//	{Annotation} "TODO";
	public AnnotationElements getAnnotationAccess() {
		return (pAnnotation != null) ? pAnnotation : (pAnnotation = new AnnotationElements());
	}
	
	public ParserRule getAnnotationRule() {
		return getAnnotationAccess().getRule();
	}

	//// A variable declaration declares a new variable and optionally assigns it a value.
	//VariableDeclaration returns Variable:
	//	type=Type name=ID (":=" initialValue=Expr);
	public VariableDeclarationElements getVariableDeclarationAccess() {
		return (pVariableDeclaration != null) ? pVariableDeclaration : (pVariableDeclaration = new VariableDeclarationElements());
	}
	
	public ParserRule getVariableDeclarationRule() {
		return getVariableDeclarationAccess().getRule();
	}

	//// An assignment assigns a value to a variable.
	//Assignment:
	//	variable=[Variable] ":=" value=Expr;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//Expr:
	//	EqualsComparison;
	public ExprElements getExprAccess() {
		return (pExpr != null) ? pExpr : (pExpr = new ExprElements());
	}
	
	public ParserRule getExprRule() {
		return getExprAccess().getRule();
	}

	//EqualsComparison returns Expression:
	//	Comparison ({Equals.left=current} "=" right=Comparison)?;
	public EqualsComparisonElements getEqualsComparisonAccess() {
		return (pEqualsComparison != null) ? pEqualsComparison : (pEqualsComparison = new EqualsComparisonElements());
	}
	
	public ParserRule getEqualsComparisonRule() {
		return getEqualsComparisonAccess().getRule();
	}

	//Comparison returns Expression:
	//	Addition ({Compare.left=current} type=ComparisonType right=Addition)?;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//ComparisonType:
	//	LessComparisonType | LessOrEqualComparisonType | GreaterOrEqualComparisonType | GreaterComparisonType;
	public ComparisonTypeElements getComparisonTypeAccess() {
		return (pComparisonType != null) ? pComparisonType : (pComparisonType = new ComparisonTypeElements());
	}
	
	public ParserRule getComparisonTypeRule() {
		return getComparisonTypeAccess().getRule();
	}

	//LessComparisonType:
	//	{LessComparisonType} "<";
	public LessComparisonTypeElements getLessComparisonTypeAccess() {
		return (pLessComparisonType != null) ? pLessComparisonType : (pLessComparisonType = new LessComparisonTypeElements());
	}
	
	public ParserRule getLessComparisonTypeRule() {
		return getLessComparisonTypeAccess().getRule();
	}

	//LessOrEqualComparisonType:
	//	{LessOrEqualComparisonType} ("<=" | "≤");
	public LessOrEqualComparisonTypeElements getLessOrEqualComparisonTypeAccess() {
		return (pLessOrEqualComparisonType != null) ? pLessOrEqualComparisonType : (pLessOrEqualComparisonType = new LessOrEqualComparisonTypeElements());
	}
	
	public ParserRule getLessOrEqualComparisonTypeRule() {
		return getLessOrEqualComparisonTypeAccess().getRule();
	}

	//GreaterOrEqualComparisonType:
	//	{GreaterOrEqualComparisonType} (">=" | "≥");
	public GreaterOrEqualComparisonTypeElements getGreaterOrEqualComparisonTypeAccess() {
		return (pGreaterOrEqualComparisonType != null) ? pGreaterOrEqualComparisonType : (pGreaterOrEqualComparisonType = new GreaterOrEqualComparisonTypeElements());
	}
	
	public ParserRule getGreaterOrEqualComparisonTypeRule() {
		return getGreaterOrEqualComparisonTypeAccess().getRule();
	}

	//GreaterComparisonType:
	//	{GreaterComparisonType} ">";
	public GreaterComparisonTypeElements getGreaterComparisonTypeAccess() {
		return (pGreaterComparisonType != null) ? pGreaterComparisonType : (pGreaterComparisonType = new GreaterComparisonTypeElements());
	}
	
	public ParserRule getGreaterComparisonTypeRule() {
		return getGreaterComparisonTypeAccess().getRule();
	}

	//Addition returns Expression:
	//	Multiplication ({Plus.left=current} type=AdditionType right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//AdditionType:
	//	AdditionOp | SubtractionOp;
	public AdditionTypeElements getAdditionTypeAccess() {
		return (pAdditionType != null) ? pAdditionType : (pAdditionType = new AdditionTypeElements());
	}
	
	public ParserRule getAdditionTypeRule() {
		return getAdditionTypeAccess().getRule();
	}

	//AdditionOp:
	//	{AdditionOp} "+";
	public AdditionOpElements getAdditionOpAccess() {
		return (pAdditionOp != null) ? pAdditionOp : (pAdditionOp = new AdditionOpElements());
	}
	
	public ParserRule getAdditionOpRule() {
		return getAdditionOpAccess().getRule();
	}

	//SubtractionOp:
	//	{SubtractionOp} "-";
	public SubtractionOpElements getSubtractionOpAccess() {
		return (pSubtractionOp != null) ? pSubtractionOp : (pSubtractionOp = new SubtractionOpElements());
	}
	
	public ParserRule getSubtractionOpRule() {
		return getSubtractionOpAccess().getRule();
	}

	//Multiplication returns Expression:
	//	PostfixOperator ({Multi.left=current} type=MultiplicationType right=PostfixOperator)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//MultiplicationType:
	//	MultiplicationOp | DivisionOp | ModuloOp;
	public MultiplicationTypeElements getMultiplicationTypeAccess() {
		return (pMultiplicationType != null) ? pMultiplicationType : (pMultiplicationType = new MultiplicationTypeElements());
	}
	
	public ParserRule getMultiplicationTypeRule() {
		return getMultiplicationTypeAccess().getRule();
	}

	//MultiplicationOp:
	//	{MultiplicationOp} ("*" | "·");
	public MultiplicationOpElements getMultiplicationOpAccess() {
		return (pMultiplicationOp != null) ? pMultiplicationOp : (pMultiplicationOp = new MultiplicationOpElements());
	}
	
	public ParserRule getMultiplicationOpRule() {
		return getMultiplicationOpAccess().getRule();
	}

	//DivisionOp:
	//	{DivisionOp} ("/" | "÷");
	public DivisionOpElements getDivisionOpAccess() {
		return (pDivisionOp != null) ? pDivisionOp : (pDivisionOp = new DivisionOpElements());
	}
	
	public ParserRule getDivisionOpRule() {
		return getDivisionOpAccess().getRule();
	}

	//ModuloOp:
	//	{ModuloOp} "%";
	public ModuloOpElements getModuloOpAccess() {
		return (pModuloOp != null) ? pModuloOp : (pModuloOp = new ModuloOpElements());
	}
	
	public ParserRule getModuloOpRule() {
		return getModuloOpAccess().getRule();
	}

	//// TODO: unary expressions
	/// *UnaryMinusOperator returns Expression:
	//	 ('-' {UnaryMinus.expr=current})? PostfixOperator
	//;* / PostfixOperator returns Expression:
	//	Atomic ({ArrayAccess.expr=current} "[" index=Expr "]")?;
	public PostfixOperatorElements getPostfixOperatorAccess() {
		return (pPostfixOperator != null) ? pPostfixOperator : (pPostfixOperator = new PostfixOperatorElements());
	}
	
	public ParserRule getPostfixOperatorRule() {
		return getPostfixOperatorAccess().getRule();
	}

	//// An atomic value in an expression is either
	////  - a function call or
	////  - a number or
	////  - a Boolean literal or
	////  - a reference to a variable
	////  - a whole new expression in parentheses.
	//Atomic returns Expression:
	//	FunctionCall | {NumberLiteral} value=INT | BooleanLiteral | VariableRef | "(" expr=Expr ")";
	public AtomicElements getAtomicAccess() {
		return (pAtomic != null) ? pAtomic : (pAtomic = new AtomicElements());
	}
	
	public ParserRule getAtomicRule() {
		return getAtomicAccess().getRule();
	}

	//// A Boolean literal is either "true" or "false"
	//BooleanLiteral:
	//	TrueLiteral | FalseLiteral;
	public BooleanLiteralElements getBooleanLiteralAccess() {
		return (pBooleanLiteral != null) ? pBooleanLiteral : (pBooleanLiteral = new BooleanLiteralElements());
	}
	
	public ParserRule getBooleanLiteralRule() {
		return getBooleanLiteralAccess().getRule();
	}

	//// A FalseLiteral is the text "false".
	//FalseLiteral:
	//	{FalseLiteral} "false";
	public FalseLiteralElements getFalseLiteralAccess() {
		return (pFalseLiteral != null) ? pFalseLiteral : (pFalseLiteral = new FalseLiteralElements());
	}
	
	public ParserRule getFalseLiteralRule() {
		return getFalseLiteralAccess().getRule();
	}

	//// A TrueLiteral is the text "true".
	//TrueLiteral:
	//	{TrueLiteral} "true";
	public TrueLiteralElements getTrueLiteralAccess() {
		return (pTrueLiteral != null) ? pTrueLiteral : (pTrueLiteral = new TrueLiteralElements());
	}
	
	public ParserRule getTrueLiteralRule() {
		return getTrueLiteralAccess().getRule();
	}

	//VariableRef:
	//	{VariableRef} symbol=[Variable];
	public VariableRefElements getVariableRefAccess() {
		return (pVariableRef != null) ? pVariableRef : (pVariableRef = new VariableRefElements());
	}
	
	public ParserRule getVariableRefRule() {
		return getVariableRefAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
