// -----------------
// UTILITY FUNCTIONS
// -----------------

// Returns the parent index of an item in the heap.
function Integer parent(Integer key1)
	_ensures _return = key1 / 2
{
	return key1 / 2
}

// Returns the index of the left child of an item in the heap.
function Integer left(Integer key2)
	_ensures _return = 2 ⋅ key2
{
	return 2 ⋅ key2
}

// Returns the index of the right child of an item in the heap.
function Integer right(Integer key3)
	_ensures _return = 2 ⋅ key3 + 1
{
	return 2 ⋅ key3 + 1
}

// Returns the size of the given heap
// (which is stored in the heap at index 0)
function Integer heapsize(Integer[] heap1)
	_requires heap1[0] ≥ 0
	_ensures _return = heap1[0]
{
	return heap1[0]
}

// Checks that the given array fulfils the heap condition
// The heap condition is defined as follows: Each element must be equal to or smaller
// than any of its child elements. 
function Boolean heapCondition(Integer[] heap)
	_requires heapsize(heap) ≥ 0
	_ensures _return = ∀ Integer i1, 2 ≤ i1 ∧ i1 ≤ heapsize(heap) : heap[parent(i1)] ≤ heap[i1]
{
	Boolean result := true
	
	if (heapsize(heap) ≥ 2) {
		Integer i3 := 2
		
		while i3 ≤ heapsize(heap)
			_invariant 2 ≤ i3 ∧ i3 ≤ heapsize(heap) + 1
			
			// The invariant is that the contents of "result" indicate whether the
			// sub-array [1..i3-1] of the input fulfils the heap condition. 
			_invariant result = ∀ Integer i4, 2 ≤ i4 ∧ i4 < i3 : heap[parent(i4)] ≤ heap[i4]
		{
			if result = true {
				if heap[parent(i3)] > heap[i3] {
					result := false
				}
			}
			
			i3 := i3 + 1
		}
	}
	
	return result
}

// -----------------
// HEAP FUNCTIONS
// -----------------

// Inserts a key into a heap.
// Ensures that the returned heap is 1 larger than the original heap
// and contains the key just inserted.
function Integer[] heapInsert(Integer[] insertHeap, Integer insertKey)
	_requires heapCondition(insertHeap)
	
	_ensures heapCondition(_return)
	_ensures heapsize(_return) = heapsize(insertHeap) + 1
	_ensures ∃ Integer i2, 1 ≤ i2 ∧ i2 ≤ heapsize(_return) : _return[i2] = insertKey
{
	Integer[] insertResult := insertHeap
	
	// Update heap size
	insertResult[0] := insertHeap[0] + 1
	Integer insertHeapSize := insertResult[0]
	Integer currentInsertIndex := insertHeapSize

	// Insert new item into heap
	insertResult[currentInsertIndex] := insertKey
	
	// Restore heap condition
	while currentInsertIndex > 1 ∧ insertResult[currentInsertIndex] > insertResult[parent(currentInsertIndex)]
		_invariant currentInsertIndex ≥ 1 ∧ currentInsertIndex ≤ heapsize(insertResult)
		_invariant insertResult[currentInsertIndex] = insertKey
	{
		Integer parentIndex := parent(currentInsertIndex)
		
		Integer tmp := insertResult[currentInsertIndex]
		insertResult[currentInsertIndex] := insertResult[parentIndex]
		insertResult[parentIndex] := tmp
	}
	
	return insertResult
}
