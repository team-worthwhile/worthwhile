// -----------------
// UTILITY FUNCTIONS
// -----------------

// Returns the parent index of an item in the heap.
function Integer parent(Integer key1)
	_ensures _return = key1 / 2
{
	return key1 / 2
}

// Returns the index of the left child of an item in the heap.
function Integer left(Integer key2)
	_ensures _return = 2 ⋅ key2
{
	return 2 ⋅ key2
}

// Returns the index of the right child of an item in the heap.
function Integer right(Integer key3)
	_ensures _return = 2 ⋅ key3 + 1
{
	return 2 ⋅ key3 + 1
}

// Returns the size of the given heap
// (which is stored in the heap at index 0)
function Integer heapsize(Integer[] heap1)
	_requires heap1[0] ≥ 0
	_ensures _return = heap1[0]
{
	return heap1[0]
}

// Checks that the given array fulfils the heap condition
// The heap condition is defined as follows: Each element must be equal to or smaller
// than any of its child elements. 
function Boolean heapCondition(Integer[] heap)
	_requires heapsize(heap) ≥ 0
	_ensures _return = ∀ Integer i1, 2 ≤ i1 ∧ i1 ≤ heapsize(heap) : heap[parent(i1)] ≤ heap[i1]
{
	Boolean result := true
	
	if (heapsize(heap) ≥ 2) {
		Integer i3 := 2
		
		while i3 ≤ heapsize(heap)
			_invariant 2 ≤ i3 ∧ i3 ≤ heapsize(heap) + 1
			
			// The invariant is that the contents of "result" indicate whether the
			// sub-array [1..i3-1] of the input fulfils the heap condition.
			_invariant result = ∀ Integer i4, 2 ≤ i4 ∧ i4 < i3 : heap[parent(i4)] ≤ heap[i4]
		{
			if result = true {
				if heap[parent(i3)] > heap[i3] {
					result := false
				}
			}
			
			i3 := i3 + 1
		}
	}
	
	return result
}

// -----------------
// HEAP FUNCTIONS
// -----------------

// Inserts a key into a heap.
// Ensures that the returned heap is 1 larger than the original heap
// and contains the key just inserted.
function Integer[] heapInsert(Integer[] insertHeap, Integer insertKey)
	_requires heapsize(insertHeap) ≥ 0
	_requires heapCondition(insertHeap)
	
	// TODO: Fehler in SMTLIB-Formel!
	_ensures heapCondition(_return)
	_ensures heapsize(_return) = heapsize(insertHeap) + 1
	_ensures ∃ Integer i2, 1 ≤ i2 ∧ i2 ≤ heapsize(_return) : _return[i2] = insertKey
{
	Integer[] insertResult := insertHeap
	
	// Enlarge the heap by one
	insertResult[0] := insertHeap[0] + 1
	Integer insertHeapSize := insertResult[0]
	Integer currentInsertIndex := insertHeapSize

	// Insert new item into heap
	insertResult[currentInsertIndex] := insertKey
	
	// If the newly inserted item is not the only one in the heap, we need to restore the heap condition
	if (currentInsertIndex > 1) {
		while currentInsertIndex > 1 ∧ insertResult[currentInsertIndex] > insertResult[parent(currentInsertIndex)]
			_invariant currentInsertIndex ≥ 1 ∧ currentInsertIndex ≤ heapsize(insertResult)
			_invariant insertResult[currentInsertIndex] = insertKey
			// _invariant ∀ Integer i5, i5 > currentInsertIndex ∧ i5 ≤ heapsize(insertResult) :  
		{
			Integer parentIndex := parent(currentInsertIndex)
			
			Integer tmp := insertResult[currentInsertIndex]
			insertResult[currentInsertIndex] := insertResult[parentIndex]
			insertResult[parentIndex] := tmp
			
			currentInsertIndex := parentIndex
		}
	}
	
	return insertResult
}

// Removes the first element of the heap, restores heap order and decreases the heap size by one
function Integer[] heapPop(Integer[] popHeap)
	_requires heapsize(popHeap) > 0
	_requires heapCondition(popHeap)
	
	_ensures heapsize(_return) = heapsize(popHeap) - 1
	_ensures heapCondition(_return)
{
	Integer[] popResult := popHeap
	popResult[1] := popResult[heapsize(popResult)]
	popResult[0] := popResult[0] - 1
	
	// TODO restore heap condition
	
	return popResult
}

// -----------------
// HEAP SORT
// -----------------

// Sorts an array using heap sort.
/*function Integer[] heapSort(Integer[] sortInput, Integer length)
	_requires length ≥ 0
	_ensures ∀ Integer i5, 1 ≤ i5 ∧ i5 < length : _return[i5 - 1] ≤ _return[i5] 
{
	Integer[] sortResult
	Integer[] tmpHeap := {0}
	
	Integer i := 0
	while (i < length) {
		tmpHeap := heapInsert(tmpHeap, sortInput[i])
		i := i + 1
	}
	
	i := 0
	while (i < length) {
		sortResult[i] := tmpHeap[1]
		tmpHeap := heapPop(tmpHeap)
		i := i + 1
	}
	
	return sortResult
}*/

Boolean b := heapCondition({3, 0, 1, 2})
b := b
